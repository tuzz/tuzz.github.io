<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><title data-react-helmet="true">How Bash completion works - tuzz.tech</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" name="author" content="Chris Patuzzo"/><meta data-react-helmet="true" property="og:title" content="How Bash completion works"/><meta data-react-helmet="true" property="og:url" content="https://tuzz.tech/blog/how-bash-completion-works"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:description" content="Ever wondered how Bash completion works? In this first article on the topic, we’ll look at how it works under the hood."/><meta data-react-helmet="true" name="description" content="Ever wondered how Bash completion works? In this first article on the topic, we’ll look at how it works under the hood."/><meta data-react-helmet="true" name="keywords" content="Chris Patuzzo,Bash,Ruby,Chef,completion,auto-completion,complete,auto-complete,how it works,behaviour,rbenv,nodenv,FizzBuzz"/><meta data-react-helmet="true" property="og:image" content="https://tuzz.tech/images/fizzbuzz-completion.gif"/><meta data-react-helmet="true" property="og:image:secure_url" content="https://tuzz.tech/images/fizzbuzz-completion.gif"/><meta data-react-helmet="true" property="og:image:width" content="800"/><meta data-react-helmet="true" property="og:image:height" content="630"/><meta data-react-helmet="true" property="og:video" content="https://tuzz.tech/videos/fizzbuzz-completion.mp4"/><meta data-react-helmet="true" property="og:video:secure_url" content="https://tuzz.tech/videos/fizzbuzz-completion.mp4"/><meta data-react-helmet="true" property="og:image:type" content="video/mp4"/><meta data-react-helmet="true" property="og:video:width" content="820"/><meta data-react-helmet="true" property="og:video:height" content="646"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/how-bash-completion-works.mdx.ae4fed56.js"/><link rel="preload" as="script" href="/templates/styles.f5f0f4b2.js"/><link rel="preload" as="script" href="/templates/vendors~main.abecbdad.js"/><link rel="preload" as="script" href="/main.4c9105b0.js"/><link rel="preload" as="style" href="/main.6c84323b.css"/><link rel="stylesheet" href="/main.6c84323b.css"/><link rel="preload" as="style" href="/styles.c538bfc6.css"/><link rel="stylesheet" href="/styles.c538bfc6.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/how-bash-completion-works.mdx.abdf87e1.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/how-bash-completion-works.mdx.abdf87e1.css"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Merriweather:400,400i|Source+Code+Pro:500,500i&amp;display=swap" rel="stylesheet"/><link data-react-helmet="true" rel="alternate" type="application/rss+xml" title="tuzz.tech" href="/feed.xml"/><link data-react-helmet="true" rel="icon" href="data:;base64,iVBORw0KGgo="/><link data-react-helmet="true" rel="prev" href="/blog/happy-100th"/><link data-react-helmet="true" rel="next" href="/blog/adding-bash-completion"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><div class="styles-layout_qpgG"><div class="styles-content_1JPb"><div style="outline:none" tabindex="-1"><div style="outline:none" tabindex="-1"><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/happy-100th">← Previous</a><a href="/blog/adding-bash-completion">Next Article →</a></span></div><h1 class="styles-h1_3RZl">How Bash completion works</h1><time dateTime="2019-10-06T12:00Z">Published <!-- -->October 6, 2019<!-- --> by <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a><a href="/feed.xml" target="_blank" class="styles-feed_icon_SE8y"><svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="3.429" cy="20.571" r="3.429"></circle><path d="m11.429 24h4.57c0-8.821-7.178-15.999-15.999-16v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path><path d="m24 24c0-13.234-10.766-24-24-24v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path></svg></a></time><span></span><div class="note">This is the first of two parts on Bash completion. Part two is <a href="/blog/adding-bash-completion">here</a>.</div><figure class="more_space styles-figure_23Vi"><a href="/videos/zz-completion.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/zz-completion.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Bash completion for <a href="https://github.com/tuzz/zz" target="_blank">‘The tuzz automation tool’</a></span></figcaption></figure><aside class="styles-aside_161L">I think ‘completion’ and ‘auto-completion’ mean the same in this context. I’ll use the former for brevity.</aside><p>Over the years I’ve developed a command-line tool I use for routine tasks such
as provisioning my machine, generating project templates and managing secrets.
The tool is written in Ruby and I invoke it with the <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span></code> command.</p><p>Most of <span>what</span> it does is fairly
straightforward. The clever bits are usually delegated to something else. For
example, <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision</span></span></code> is really just a wrapper that installs and runs Chef,
while passing various options to it.</p><aside class="styles-aside_161L"><p>It uses <a href="https://docs.chef.io/chef_solo.html" target="_blank">chef-solo</a> which is a slimmed down
version of Chef that runs on a single node. No server needed.</p></aside><p>Recently, I added Bash completion to my tool. I’ve wanted this for a while, but
decided to add it now in preparation for <span>secrets
management.</span> For example, I want to be able to type <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz secret --read</span></span><span class="token-line"><span class="token plain">amaz&lt;TAB&gt;&lt;TAB&gt;</span></span></code> and have it complete to <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz secret --read amazon/</span></span></code>.  Perhaps
hitting <code class="prism-code language-none"><span class="token-line"><span class="token plain">&lt;TAB&gt;</span></span></code> again will list all secrets under this path, e.g. username,
password, access_key, etc.</p><aside class="styles-aside_161L"><p>I haven’t actually implemented secrets management yet. Currently, I’m running
<code class="prism-code language-none"><span class="token-line"><span class="token plain">gpg --encrypt</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">--decrypt</span></span></code> a lot so hopefully I’ll find time to add this
feature soon.</p></aside><a href="#the-mechanics"><h2 id="the-mechanics" class="styles-h2_13mz">The mechanics</h2></a><p>In <span>Bash</span>, completion is handled through the <code class="prism-code language-none"><span class="token-line"><span class="token plain">complete</span></span></code> ‘built-in’:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ </span><span class="token builtin class-name">type</span><span class="token plain"> complete</span></span><span class="token-line"><span class="token plain">complete is a shell </span><span class="token builtin class-name">builtin</span></span></code></pre></div><aside class="styles-aside_161L"><p><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html" target="_blank">Builtins</a>
are commands ‘built into’ the shell. They provide basic operations like <code class="prism-code language-none"><span class="token-line"><span class="token plain">echo</span></span></code>,
<code class="prism-code language-none"><span class="token-line"><span class="token plain">help</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">type</span></span></code>:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ </span><span class="token builtin class-name">type</span><span class="token plain"> </span><span class="token builtin class-name">type</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token builtin class-name">type</span><span class="token plain"> is a shell </span><span class="token builtin class-name">builtin</span></span></code></pre></div></aside><p>This command allows you to register a method of completion for a command. For
example, an <code class="prism-code language-none"><span class="token-line"><span class="token plain">rgb</span></span></code> command might register its known colors:</p><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ complete -W </span><span class="token string">&quot;red green blue yellow purple pink orange&quot;</span><span class="token plain"> color</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Setting a hardcoded list of completions</p></span></figcaption></figure><p>You could then complete color names:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ color </span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">blue    green   orange  pink    purple  red     yellow</span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">$ color p</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">pink    purple</span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">$ color pi</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token comment"># completes to pink</span></span></code></pre></div><p>The <code class="prism-code language-none"><span class="token-line"><span class="token plain">-W</span></span></code> switch configures a static list of completions that are printed in
alphabetical order. It’s just one of the many methods of <span>completion.</span></p><aside class="styles-aside_161L"><p>It’s also the simplest.</p></aside><a href="#listing-completion-methods"><h3 id="listing-completion-methods" class="styles-h3_yb8_">Listing completion methods</h3></a><p>To see which commands have completion methods, run <code class="prism-code language-none"><span class="token-line"><span class="token plain">complete</span></span></code> without arguments:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ complete</span></span><span class="token-line"><span class="token plain">complete -W </span><span class="token string">&#x27;red green blue yellow purple pink orange&#x27;</span><span class="token plain"> color</span></span><span class="token-line"><span class="token plain">complete -F _nodenv nodenv</span></span><span class="token-line"><span class="token plain">complete -F _rbenv rbenv</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Listing all registered completion methods</p></span></figcaption></figure><aside class="styles-aside_161L"><p>If you try to complete commands without registered methods, Bash uses its default behaviour and lists files in the current directory.</p></aside><p>Here you can see <code class="prism-code language-none"><span class="token-line"><span class="token plain">nodenv</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">rbenv</span></span></code> support completion. They use the <code class="prism-code language-none"><span class="token-line"><span class="token plain">-F</span></span></code>
switch to specify functions to handle their completion, <span>namely</span> <code class="prism-code language-none"><span class="token-line"><span class="token plain">_nodenv</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">_rbenv</span></span></code>. When you complete one of
these commands, their output is context-aware:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ rbenv </span><span class="token function">install</span><span class="token plain"> </span><span class="token number">2</span><span class="token plain">.</span><span class="token operator file-descriptor important">5</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token number">2.5</span><span class="token plain">.0          </span><span class="token number">2.5</span><span class="token plain">.0-rc1      </span><span class="token number">2.5</span><span class="token plain">.1          </span><span class="token number">2.5</span><span class="token plain">.2          </span><span class="token number">2.5</span><span class="token plain">.3</span></span></code></pre></div><aside class="styles-aside_161L"><p>It seems to be a convention to name these Bash functions <code class="prism-code language-none"><span class="token-line"><span class="token plain">_&lt;command&gt;</span></span></code>.</p></aside><p>That’s helpful! <code class="prism-code language-none"><span class="token-line"><span class="token plain">rbenv</span></span></code> has kindly listed which Ruby <strong>2.5.x</strong> versions are available
to install. We could find this out from <code class="prism-code language-none"><span class="token-line"><span class="token plain">rbenv install --list</span></span></code> but that’s
inefficient because we’d have to clear our current command then re-type it.</p><a href="#how-completion-functions-work"><h2 id="how-completion-functions-work" class="styles-h2_13mz">How completion <em>functions</em> work</h2></a><p>When a function is registered as the method of completion with the <code class="prism-code language-none"><span class="token-line"><span class="token plain">-F</span></span></code> switch,
it must comply with an ‘interface’ of sorts. When the function is called, Bash
sets some environment variables to be used by the completion function.</p><p>They <span>tell</span> it the contents of the
command-line, the cursor position, etc. For example, <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMP_LINE</span></span></code> contains the
full line that was typed, <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMP_WORDS</span></span></code> is that same line broken into an array
of words and <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMP_POINT</span></span></code> is the cursor’s index position.</p><p>In return, the completion function should set <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMPREPLY</span></span></code> to specify which
completions to print for the command.</p><aside class="styles-aside_161L"><p>Using environment variables as a means of passing information back and forth
seems kind of awkward. Bash <em>is</em> pretty old, though.</p></aside><a href="#an-example"><h3 id="an-example" class="styles-h3_yb8_">An example</h3></a><p>Everybody loves FizzBuzz, right? Let’s demonstrate Bash completion with a custom
function that <em>magically</em> completes the next term in the sequence:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function-name function">_fizzbuzz</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token assign-left variable">length</span><span class="token operator">=</span><span class="token variable">${</span><span class="token variable operator">#</span><span class="token variable">COMP_WORDS</span><span class="token variable punctuation">[</span><span class="token variable">@</span><span class="token variable punctuation">]</span><span class="token variable">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token variable">$((</span><span class="token variable">length </span><span class="token variable operator">-</span><span class="token variable"> </span><span class="token variable number">1</span><span class="token variable">))</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">if</span><span class="token plain">   </span><span class="token operator">!</span><span class="token plain"> </span><span class="token variable punctuation">((</span><span class="token variable">number </span><span class="token variable operator">%</span><span class="token variable"> </span><span class="token variable number">15</span><span class="token variable punctuation">))</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token keyword">then</span><span class="token plain"> </span><span class="token assign-left variable">COMPREPLY</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token plain">fizzbuzz</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">elif</span><span class="token plain"> </span><span class="token operator">!</span><span class="token plain"> </span><span class="token variable punctuation">((</span><span class="token variable">number </span><span class="token variable operator">%</span><span class="token variable"> </span><span class="token variable number">3</span><span class="token variable punctuation">))</span><span class="token punctuation">;</span><span class="token plain">  </span><span class="token keyword">then</span><span class="token plain"> </span><span class="token assign-left variable">COMPREPLY</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token plain">fizz</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">elif</span><span class="token plain"> </span><span class="token operator">!</span><span class="token plain"> </span><span class="token variable punctuation">((</span><span class="token variable">number </span><span class="token variable operator">%</span><span class="token variable"> </span><span class="token variable number">5</span><span class="token variable punctuation">))</span><span class="token punctuation">;</span><span class="token plain">  </span><span class="token keyword">then</span><span class="token plain"> </span><span class="token assign-left variable">COMPREPLY</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token plain">buzz</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">else</span><span class="token plain">                         </span><span class="token assign-left variable">COMPREPLY</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">fi</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">complete -F _fizzbuzz fizzbuzz</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Setting a Bash function to complete <code class="prism-code language-none"><span class="token-line"><span class="token plain">fizzbuzz</span></span></code></p></span></figcaption></figure><aside class="styles-aside_161L"><p>In Bash, you can access elements in an array, or get its length like this:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token assign-left variable">first</span><span class="token operator">=</span><span class="token variable">${SOME_ARRAY</span><span class="token variable punctuation">[</span><span class="token variable">0</span><span class="token variable punctuation">]</span><span class="token variable">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token assign-left variable">second</span><span class="token operator">=</span><span class="token variable">${SOME_ARRAY</span><span class="token variable punctuation">[</span><span class="token variable">1</span><span class="token variable punctuation">]</span><span class="token variable">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token assign-left variable">length</span><span class="token operator">=</span><span class="token variable">${</span><span class="token variable operator">#</span><span class="token variable">SOME_ARRAY</span><span class="token variable punctuation">[</span><span class="token variable">@</span><span class="token variable punctuation">]</span><span class="token variable">}</span></span></code></pre></div></aside><p>Our <span>command</span> is called <code class="prism-code language-none"><span class="token-line"><span class="token plain">fizzbuzz</span></span></code> so we name
our completion function <code class="prism-code language-none"><span class="token-line"><span class="token plain">_fizzbuzz</span></span></code>, as per the convention. We first set the
<code class="prism-code language-none"><span class="token-line"><span class="token plain">length</span></span></code> variable to the number of words on the command-line and <code class="prism-code language-none"><span class="token-line"><span class="token plain">number</span></span></code> to
one less, since ‘<code class="prism-code language-none"><span class="token-line"><span class="token plain">fizzbuzz</span></span></code>’ itself counts as a word.</p><p>We’ve probably all seen FizzBuzz before so let’s skip the modulo logic. The
important part is to set <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMPREPLY</span></span></code> - in this case, to an array of the next
term in the sequence.</p><p>Now, if we type <code class="prism-code language-none"><span class="token-line"><span class="token plain">fizzbuzz &lt;TAB&gt;&lt;TAB&gt;</span></span></code>, Bash completion kicks in and as if by
<em>magic</em> the next term is appended to the current command-line.  Our <code class="prism-code language-none"><span class="token-line"><span class="token plain">fizzbuzz</span></span></code>
command doesn’t actually exist but that doesn’t seem to matter!</p><aside class="styles-aside_161L"><p>I do wonder if this could be used as an attack vector:</p><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function-name function">_ls</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token comment"># do something nasty</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">complete -F _ls </span><span class="token function">ls</span></span></code></pre></div><p>Of course, we’d need permissions to register completion functions which we won’t
have so it’s probably fine?</p></aside><span></span><span></span><figure class="more_space styles-figure_23Vi"><a href="/videos/fizzbuzz-completion.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/fizzbuzz-completion.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Using Bash completion to generate the FizzBuzz sequence</span></figcaption></figure><aside class="styles-aside_161L"><p>If the completion function returns a single option, Bash immediately completes
it without prompting us.</p><p>That means we can hold down <code class="prism-code language-none"><span class="token-line"><span class="token plain">&lt;TAB&gt;</span></span></code> to continuously complete the FizzBuzz
sequence. Hooray!</p></aside><aside class="styles-aside_161L"><p>Surely this is the best way to implement FizzBuzz in a coding interview? Or
maybe <a href="https://github.com/tuzz/fizzquinebuzz" target="_blank">this</a>?</p></aside><p>As you can see, there’s plenty of fun to be had! In
<a href="/blog/adding-bash-completion">part two</a> we’ll implement Bash completion for my
automation tool and see how it works in practice.</p><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/happy-100th">← Previous</a><a href="/blog/adding-bash-completion">Next Article →</a></span></div></div></div></div></div><div class="styles-footer_1oSO"><p>© <!-- -->2020<!-- --> <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a></p></div></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/app/pages/blog/how-bash-completion-works.mdx\",\"sharedHashesByProp\":{},\"data\":{},\"path\":\"blog/how-bash-completion-works\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/how-bash-completion-works.mdx.ae4fed56.js"></script><script defer="" type="text/javascript" src="/templates/styles.f5f0f4b2.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.abecbdad.js"></script><script defer="" type="text/javascript" src="/main.4c9105b0.js"></script></body></html>