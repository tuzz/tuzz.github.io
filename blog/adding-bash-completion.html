<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Adding Bash completion to my tool - tuzz.tech</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" name="author" content="Chris Patuzzo"/><meta data-react-helmet="true" property="og:title" content="Adding Bash completion to my tool"/><meta data-react-helmet="true" property="og:url" content="https://tuzz.tech/blog/adding-bash-completion"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:description" content="In this second article on Bash completion, we’ll see to apply it to a real-world use case: The tuzz automation tool."/><meta data-react-helmet="true" name="description" content="In this second article on Bash completion, we’ll see to apply it to a real-world use case: The tuzz automation tool."/><meta data-react-helmet="true" name="keywords" content="Chris Patuzzo,Bash,Ruby,completion,auto-completion,complete,auto-complete,behaviour"/><meta data-react-helmet="true" property="og:image" content="https://tuzz.tech/images/zz-completion.gif"/><meta data-react-helmet="true" property="og:image:secure_url" content="https://tuzz.tech/images/zz-completion.gif"/><meta data-react-helmet="true" property="og:image:width" content="1012"/><meta data-react-helmet="true" property="og:image:height" content="480"/><meta data-react-helmet="true" property="og:video" content="https://tuzz.tech/videos/zz-completion.mp4"/><meta data-react-helmet="true" property="og:video:secure_url" content="https://tuzz.tech/videos/zz-completion.mp4"/><meta data-react-helmet="true" property="og:image:type" content="video/mp4"/><meta data-react-helmet="true" property="og:video:width" content="1362"/><meta data-react-helmet="true" property="og:video:height" content="646"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx.93994418.js"/><link rel="preload" as="script" href="/templates/styles.f5f0f4b2.js"/><link rel="preload" as="script" href="/templates/vendors~main.abecbdad.js"/><link rel="preload" as="script" href="/main.4c9105b0.js"/><link rel="preload" as="style" href="/main.6c84323b.css"/><link rel="stylesheet" href="/main.6c84323b.css"/><link rel="preload" as="style" href="/styles.c538bfc6.css"/><link rel="stylesheet" href="/styles.c538bfc6.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx.abdf87e1.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx.abdf87e1.css"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Merriweather:400,400i|Source+Code+Pro:500,500i&amp;display=swap" rel="stylesheet"/><link data-react-helmet="true" rel="alternate" type="application/rss+xml" title="tuzz.tech" href="/feed.xml"/><link data-react-helmet="true" rel="icon" href="data:;base64,iVBORw0KGgo="/><link data-react-helmet="true" rel="prev" href="/blog/how-bash-completion-works"/><link data-react-helmet="true" rel="next" href="/blog/palindromic-superpermutations"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><div class="styles-layout_qpgG"><div class="styles-content_1JPb"><div style="outline:none" tabindex="-1"><div style="outline:none" tabindex="-1"><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/how-bash-completion-works">← Previous</a><a href="/blog/palindromic-superpermutations">Next Article →</a></span></div><h1 class="styles-h1_3RZl">Adding Bash completion to my tool</h1><time dateTime="2019-10-06T12:01Z">Published <!-- -->October 6, 2019<!-- --> by <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a><a href="/feed.xml" target="_blank" class="styles-feed_icon_SE8y"><svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="3.429" cy="20.571" r="3.429"></circle><path d="m11.429 24h4.57c0-8.821-7.178-15.999-15.999-16v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path><path d="m24 24c0-13.234-10.766-24-24-24v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path></svg></a></time><span></span><div class="note">This is the second of two parts on Bash completion. Part one is <a href="/blog/how-bash-completion-works">here</a>.</div><figure class="more_space styles-figure_23Vi"><a href="/videos/zz-completion.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/zz-completion.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>A reminder of what we’re trying to achieve</span></figcaption></figure><p>In part one we looked at the basic mechanics of Bash completion. In this part
we’ll walk through its implementation for my automation tool.</p><aside class="styles-aside_161L"><p>A quick refresher on part one:</p><ul><li>The <code class="prism-code language-none"><span class="token-line"><span class="token plain">complete</span></span></code> command lets us get/set completion functions</li><li>These functions communicate via environment variables</li><li>Completion kicks in when we hit <code class="prism-code language-none"><span class="token-line"><span class="token plain">&lt;TAB&gt;</span></span></code> on the command-line</li></ul></aside><p>Recap: My tool is called <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span></code> and I use it every day for routine tasks like
provisioning my machine and generating project templates. The animation above
shows some example use cases of Bash completion, e.g. completing <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz pr</span></span></code> to <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span><span class="token-line"><span class="token plain">provision</span></span></code>.</p><a href="#the-zz-completion-function"><h2 id="the-zz-completion-function" class="styles-h2_13mz">The ‘zz’ completion function</h2></a><p>I <span>added</span> Bash completion support in <a href="https://github.com/tuzz/zz/commit/c7c90d292a19d2c880c9bac6b50e3d1f0ccfc414" target="_blank">this
commit</a>.</p><aside class="styles-aside_161L"><p>This article is more Ruby-specific and walks through my commits.</p></aside><p>First, I register a completion function that passes the entire command line
through to another <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span></code> command. Then <code class="prism-code language-none"><span class="token-line"><span class="token plain">$COMPREPLY</span></span></code> is set to the result of that
command:</p><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token shebang important">#!/bin/bash</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function-name function">_zz</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token assign-left variable">COMPREPLY</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$(</span><span class="token variable">zz complete $COMP_LINE</span><span class="token variable">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">complete -F _zz zz</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Setting a Bash function to complete <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span></code></p></span></figcaption></figure><p>My philosophy with these things is to ‘get the hell out of <code class="prism-code language-none"><span class="token-line"><span class="token plain">&lt;OBSCURE THING&gt;</span></span></code>’
as soon as possible and handle the result in a more <span>conventional</span> way. In this case, I want to use my trusty
friend <em>Ruby</em> to determine the list of completions. This may as well be <em>just
another</em> <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz</span></span></code> command since I’ll need access to the tool’s context.</p><aside class="styles-aside_161L"><p>e.g. I do the same with <a href="https://ruby.github.io/rake/doc/rakefile_rdoc.html" target="_blank">Rakefiles</a></p></aside><p>The <span>file</span> is written to
<code class="prism-code language-none"><span class="token-line"><span class="token plain">/usr/local/bin/zz-completion.bash</span></span></code> and I source it in my <code class="prism-code language-none"><span class="token-line"><span class="token plain">~/.profile</span></span></code>. I’m
actually using <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision</span></span></code> to ensure this file exists and that it’s sourced.
Now on to the tool-specific behaviour<!-- -->…</p><aside class="styles-aside_161L"><p>I’m particularly fond of this kind of ‘bootstrapping’ since it pushes the tool in to the realms of self-reference.</p></aside><a href="#completing-command-names"><h2 id="completing-command-names" class="styles-h2_13mz">Completing command names</h2></a><p>My <span>first</span> goal is to implement completion for
commands and options. The idea being, if I type <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz prov</span></span></code> that should complete
to <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision</span></span></code> and if I type <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz &lt;TAB&gt;&lt;TAB&gt;</span></span></code>, it should provide a friendly
reminder of all available commands.</p><aside class="styles-aside_161L"><p>How it should work is somewhat arbitrary, but this behaviour seems most intuitive to me.</p></aside><p>The same goes for options. If I type <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision --li&lt;TAB&gt;</span></span></code>, I’d like that to
complete to <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision --list</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz provision --&lt;TAB&gt;&lt;TAB&gt;</span></span></code> would
remind me of options for the <code class="prism-code language-none"><span class="token-line"><span class="token plain">provision</span></span></code> command.</p><p>This <span>behaviour</span> is implemented in
<a href="https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e" target="_blank">this commit</a>.</p><aside class="styles-aside_161L"><p>It’s probably easier to look at the tests rather than the implementation.</p></aside><p>It gets complicated and I could have simplified further. I’m happy it’s
tested and can be refactored later if needs be. I decided to split the code up
by the ‘type’ of completion, i.e. whether it’s the name of a command, an
option, or its <span>arguments</span>.</p><aside class="styles-aside_161L"><p>More on this later.</p></aside><p>For each type of completion, I defined a method that takes <code class="prism-code language-none"><span class="token-line"><span class="token plain">args</span></span></code> which is the
full command-line typed by the user as an array of words. The method returns
strings which are fed back as the completion options:</p><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token keyword">def</span><span class="token plain"> </span><span class="token method-definition function">complete_command</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  commands </span><span class="token operator">=</span><span class="token plain"> filter_commands</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token comment"># ...</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  commands</span><span class="token punctuation">.</span><span class="token plain">map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token symbol">:name</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">end</span></span></code></pre></div><span></span><p>I made it so these methods can return <code class="prism-code language-none"><span class="token-line"><span class="token plain">false</span></span></code> if this type of completion isn’t
relevant. For example, if the user has already typed <code class="prism-code language-none"><span class="token-line"><span class="token plain">provision</span></span></code> (a command), it
doesn’t make sense to complete the name of a command since we already have that:</p><aside class="styles-aside_161L"><p>That means we can or (<code class="prism-code language-none"><span class="token-line"><span class="token plain">||</span></span></code>) all our completion methods together to find the
first one that’s ‘relevant’.</p><p>This behaviour is implemented
<a href="https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e#diff-c536662908a26a0b8843e81b8ffe42cbR5" target="_blank">here</a>.</p></aside><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token keyword">def</span><span class="token plain"> </span><span class="token method-definition function">complete_command</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  commands </span><span class="token operator">=</span><span class="token plain"> filter_commands</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword">false</span><span class="token plain"> </span><span class="token keyword">if</span><span class="token plain"> args</span><span class="token punctuation">.</span><span class="token plain">size </span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token number">2</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token keyword">false</span><span class="token plain"> </span><span class="token keyword">if</span><span class="token plain"> exact_command_match</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token plain">commands</span><span class="token punctuation">,</span><span class="token plain"> args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  commands</span><span class="token punctuation">.</span><span class="token plain">map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token symbol">:name</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">end</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Returning <code class="prism-code language-none"><span class="token-line"><span class="token plain">false</span></span></code> if this ‘type’ of completion isn’t relevant</p></span></figcaption></figure><p>The <a href="https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e#diff-c536662908a26a0b8843e81b8ffe42cbR40-R55" target="_blank"><code class="prism-code language-none"><span class="token-line"><span class="token plain">#complete_option</span></span></code></a>
method is more complicated but uses the same idea.</p><a href="#completing-option-arguments"><h2 id="completing-option-arguments" class="styles-h2_13mz">Completing option arguments</h2></a><p>The final piece of the puzzle is to do contextual completion for options.
My original use-case was to complete <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz secret --read amaz</span></span></code> to <code class="prism-code language-none"><span class="token-line"><span class="token plain">zz secret</span></span><span class="token-line"><span class="token plain">--read amazon/</span></span></code> which means we need to produce different completions per option.</p><p>Conceptually, it would be nice if <code class="prism-code language-none"><span class="token-line"><span class="token plain">--read</span></span></code> were ‘responsible’ for
determining its list of completions. Perhaps it looks at the file system or
<a href="https://www.vaultproject.io/" target="_blank">Hashicorp’s Vault</a> to decide.</p><p>I haven’t <span>implemented</span> the <code class="prism-code language-none"><span class="token-line"><span class="token plain">secret</span></span></code> command
yet, but I can still do some ground work for completion now. <a href="https://github.com/tuzz/zz/commit/fddbf52238d3e4ab490750f08148b98a6d20b8d1" target="_blank">This
commit</a>
implements <code class="prism-code language-none"><span class="token-line"><span class="token plain">#complete_option_arg</span></span></code> which delegates to a Ruby <code class="prism-code language-none"><span class="token-line"><span class="token plain">proc</span></span></code> that can be
set on an <code class="prism-code language-none"><span class="token-line"><span class="token plain">Option</span></span></code>.</p><aside class="styles-aside_161L"><p>The details here don’t matter. The key is to make <code class="prism-code language-none"><span class="token-line"><span class="token plain">Option</span></span></code> responsible for
producing its completions.</p></aside><p>We <span>can</span> now implement completion for options
by providing them with blocks. For example, here’s how we do that for <code class="prism-code language-none"><span class="token-line"><span class="token plain">template</span></span><span class="token-line"><span class="token plain">--type</span></span></code>:</p><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token keyword">def</span><span class="token plain"> </span><span class="token method-definition function">type_option</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  help </span><span class="token operator">=</span><span class="token plain"> </span><span class="token string">&quot;sets the type of template (e.g. ruby)&quot;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token variable">@type_option</span><span class="token plain"> </span><span class="token operator">||</span><span class="token operator">=</span><span class="token plain"> </span><span class="token constant">Option</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;t&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;type&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">,</span><span class="token plain"> help</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token keyword">do</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain">args</span><span class="token operator">|</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">    types</span><span class="token punctuation">.</span><span class="token plain">select </span><span class="token punctuation">{</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain">t</span><span class="token operator">|</span><span class="token plain"> t</span><span class="token punctuation">.</span><span class="token plain">start_with</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">.</span><span class="token plain">last</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">end</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">end</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Selecting all types that start with the prefix</p></span></figcaption></figure><aside class="styles-aside_161L"><p>At time of writing, valid template ‘types’ are <code class="prism-code language-none"><span class="token-line"><span class="token plain">ruby</span></span></code>, <code class="prism-code language-none"><span class="token-line"><span class="token plain">rust</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">cpp</span></span></code>.</p></aside><p>The block receives all command-line arguments and returns an array of completion
strings. In this case, we find all template types that start with the last
argument on the command-line, so if the user types <code class="prism-code language-none"><span class="token-line"><span class="token plain">template --type ru</span></span></code>, it
selects <code class="prism-code language-none"><span class="token-line"><span class="token plain">ruby</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">rust</span></span></code>.</p><p>A more complicated example is the <code class="prism-code language-none"><span class="token-line"><span class="token plain">provision --only</span></span></code> option which accepts a list
of Chef recipes. For example, you might say <code class="prism-code language-none"><span class="token-line"><span class="token plain">provision --only vim,ruby</span></span></code>.</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token keyword">def</span><span class="token plain"> </span><span class="token method-definition function">auto_complete_recipe_list</span><span class="token punctuation">(</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token operator">*</span><span class="token plain">head</span><span class="token punctuation">,</span><span class="token plain"> prefix </span><span class="token operator">=</span><span class="token plain"> args</span><span class="token punctuation">.</span><span class="token plain">last</span><span class="token punctuation">.</span><span class="token plain">downcase</span><span class="token punctuation">.</span><span class="token plain">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  list </span><span class="token operator">=</span><span class="token plain"> recipes</span><span class="token punctuation">.</span><span class="token plain">select </span><span class="token punctuation">{</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain">r</span><span class="token operator">|</span><span class="token plain"> r</span><span class="token punctuation">.</span><span class="token plain">start_with</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token plain">prefix </span><span class="token operator">||</span><span class="token plain"> </span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> recipes </span><span class="token keyword">if</span><span class="token plain"> list </span><span class="token operator">==</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">prefix</span><span class="token punctuation">]</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">  list</span><span class="token punctuation">.</span><span class="token plain">map </span><span class="token punctuation">{</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain">l</span><span class="token operator">|</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">head </span><span class="token operator">+</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">l</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">join</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">end</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>An option that completes comma-separated lists</p></span></figcaption></figure><aside class="styles-aside_161L"><p>Implemented in <a href="https://github.com/tuzz/zz/commit/62dbff256963d8ff0a8e23f54e0b5969fd277ba5" target="_blank">this commit</a>.</p><p>That mysterious <code class="prism-code language-none"><span class="token-line"><span class="token plain">return</span></span></code> statement is explained below.</p></aside><a href="#a-few-gotchas"><h3 id="a-few-gotchas" class="styles-h3_yb8_">A few ‘gotchas’</h3></a><p>Bash sometimes tries to be <span>helpful</span> which can
often lead to surprising behaviour. For example, if all available completions
start with the same prefix, Bash replaces the word at the end of the
command-line with that prefix.</p><aside class="styles-aside_161L"><p>e.g. if we returned <code class="prism-code language-none"><span class="token-line"><span class="token plain">ruby</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">rust</span></span></code> as our completions, Bash would replace the
last word with ‘<code class="prism-code language-none"><span class="token-line"><span class="token plain">ru</span></span></code>’ since that’s the common prefix.</p></aside><p>That’s why we have to copy the list into each completion:</p><span></span><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ zz provision --only vim,ru</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">vim,ruby  vim,rust</span></span></code></pre></div><aside class="styles-aside_161L"><p>Otherwise, we’d lose <code class="prism-code language-none"><span class="token-line"><span class="token plain">vim</span></span></code> from our list if it was replaced with just ‘<code class="prism-code language-none"><span class="token-line"><span class="token plain">ru</span></span></code>’.</p></aside><p>However, this can be noisy if we have lots of completion options:</p><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ zz provision --only vim,ruby</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">vim,ruby,aws   vim,ruby,chrome   vim,ruby,dock   </span><span class="token comment"># ...many more</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Noisy output: the comma-separated list is duplicated</p></span></figcaption></figure><p>Ideally, we want it to just return the names of available recipes without all
the noise but we can’t do that because Bash will replace our list by the common
prefix. In this situation, Bash’s helpfulness has backfired and results in more
noise than we’d like.</p><a href="#fighting-back"><h3 id="fighting-back" class="styles-h3_yb8_">Fighting back</h3></a><p>Knowledge is <span>power</span> and it so happens there’s
this <em>one weird trick</em> we can use to get around the problem. Since we know Bash
will only do the ‘wrong’ thing if there’s a common prefix, we can check for
that and return a clutter-free list when there isn’t:</p><aside class="styles-aside_161L"><p>Arguably, this approach could be brittle if small changes are made to how Bash
completion works, but I don’t see that happening soon.</p><p>It might also vary by operating system or version, I’m not sure.</p></aside><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">$ zz provision --only vim,ruby</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token plain">TAB</span><span class="token operator">&gt;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">aws   chrome   dock   drive   dropbox   ffmpeg   </span><span class="token comment"># ...</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Less noisy output: without the duplication</p></span></figcaption></figure><p>That’s what this lines is for:</p><span></span><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token keyword">return</span><span class="token plain"> recipes </span><span class="token keyword">if</span><span class="token plain"> list </span><span class="token operator">==</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">prefix</span><span class="token punctuation">]</span></span></code></pre></div><aside class="styles-aside_161L"><p>It’s might be useful to refer back to <code class="prism-code language-none"><span class="token-line"><span class="token plain">#auto_complete_recipe_list</span></span></code>, but I had to
stare at this for several minutes to remember how it works.</p></aside><p>My implementation’s a bit simpler in that it just checks for an exact match
between the prefix and the filtered list of recipes. This has the desired
effect because completing <code class="prism-code language-none"><span class="token-line"><span class="token plain">vim,ruby</span></span></code> or <code class="prism-code language-none"><span class="token-line"><span class="token plain">vim,</span></span></code> now displays the full list of
recipes.</p><p>This could be smarter and check for a ‘common prefix’ more directly, but it’s
already complicated. Here are some unit test for this behaviour:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-ruby"><code class="prism-code language-ruby"><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to include</span><span class="token punctuation">(</span><span class="token string">&quot;git&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;ruby&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;vim&quot;</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;ru&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to eq </span><span class="token punctuation">[</span><span class="token string">&quot;ruby&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;rust&quot;</span><span class="token punctuation">]</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;VI&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to eq </span><span class="token punctuation">[</span><span class="token string">&quot;vim&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;virtualbox&quot;</span><span class="token punctuation">]</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;x&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to eq </span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;ruby&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to include</span><span class="token punctuation">(</span><span class="token string">&quot;git&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;ruby&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;vim&quot;</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token comment"># Although this exact-matches, there are other options:</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">expect</span><span class="token punctuation">(</span><span class="token plain">complete</span><span class="token punctuation">.</span><span class="token plain">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;Chrome&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token plain">to eq </span><span class="token punctuation">[</span><span class="token string">&quot;chrome&quot;</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token string">&quot;chromedriver&quot;</span><span class="token punctuation">]</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token comment"># ...</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Unit tests for <code class="prism-code language-none"><span class="token-line"><span class="token plain">provision --only</span></span></code> option completion</p></span></figcaption></figure><aside class="styles-aside_161L"><p>I also automatically downcase the user-input in case I’m feeling overly
pedantic and want to use proper nouns, e.g. <code class="prism-code language-none"><span class="token-line"><span class="token plain">Vim,Ruby</span></span></code></p></aside><a href="#closing-remarks"><h2 id="closing-remarks" class="styles-h2_13mz">Closing remarks</h2></a><p>It’s been fun to understand the mechanics of feature we often don’t think about.
Bash completion adds a friendly touch that can make our command-line tools
easier to use through back-and-forth interactions with the user.</p><p>I think we should <span>consider</span> completion
features in the context of user experience, accessibility and interface design.
We should strive to build completion behaviours that help users navigate our
tools and discover features.</p><aside class="styles-aside_161L"><p>I’m not saying it’ll make things drastically better, but it all adds up.</p></aside><p>For those implementing this behaviour, it’s helpful to know we can ‘escape’ out
to our favourite programming languages without too much difficulty. This blog
post has been about Bash because that’s what I use, but the concepts should be
applicable wherever it’s implemented - though the mechanics will be different.</p><p>Finally, <span>I’d</span> be interested to hear if you
come up with some novel way to use completion. <a href="https://twitter.com/chrispatuzzo" target="_blank">Tweet at
me</a> if you write your own choose-your-own
adventure game with it, or some wacky chess program.</p><aside class="styles-aside_161L"><p>Or have your completion function tweet at me with the contents of your current command-line.</p></aside><p>Happy completi<code class="prism-code language-none"><span class="token-line"><span class="token plain">&lt;TAB&gt;&lt;TAB&gt;</span></span></code></p><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/how-bash-completion-works">← Previous</a><a href="/blog/palindromic-superpermutations">Next Article →</a></span></div></div></div></div></div><div class="styles-footer_1oSO"><p>© <!-- -->2020<!-- --> <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a></p></div></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/app/pages/blog/adding-bash-completion.mdx\",\"sharedHashesByProp\":{},\"data\":{},\"path\":\"blog/adding-bash-completion\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx.93994418.js"></script><script defer="" type="text/javascript" src="/templates/styles.f5f0f4b2.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.abecbdad.js"></script><script defer="" type="text/javascript" src="/main.4c9105b0.js"></script></body></html>