<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Searching for palindromic superpermutations - tuzz.tech</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" name="author" content="Chris Patuzzo"/><meta data-react-helmet="true" property="og:title" content="Searching for palindromic superpermutations"/><meta data-react-helmet="true" property="og:url" content="https://tuzz.tech/blog/palindromic-superpermutations"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:description" content="I wrote a search algorithm to tackle a challenging combinatorial problem."/><meta data-react-helmet="true" name="description" content="I wrote a search algorithm to tackle a challenging combinatorial problem."/><meta data-react-helmet="true" name="keywords" content="Chris Patuzzo,superpermutation,search algorithm,depth first,Chaffin method,palindrome,branch and bound,incremental search,combinatorics"/><meta data-react-helmet="true" property="og:image" content="https://tuzz.tech/images/chaffin-search.gif"/><meta data-react-helmet="true" property="og:image:secure_url" content="https://tuzz.tech/images/chaffin-search.gif"/><meta data-react-helmet="true" property="og:image:width" content="800"/><meta data-react-helmet="true" property="og:image:height" content="435"/><meta data-react-helmet="true" property="og:video" content="https://tuzz.tech/videos/chaffin-search.mp4"/><meta data-react-helmet="true" property="og:video:secure_url" content="https://tuzz.tech/videos/chaffin-search.mp4"/><meta data-react-helmet="true" property="og:image:type" content="video/mp4"/><meta data-react-helmet="true" property="og:video:width" content="1280"/><meta data-react-helmet="true" property="og:video:height" content="696"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/palindromic-superpermutations.mdx.e4d75d06.js"/><link rel="preload" as="script" href="/templates/styles.f5f0f4b2.js"/><link rel="preload" as="script" href="/templates/vendors~main.abecbdad.js"/><link rel="preload" as="script" href="/main.4c9105b0.js"/><link rel="preload" as="style" href="/main.6c84323b.css"/><link rel="stylesheet" href="/main.6c84323b.css"/><link rel="preload" as="style" href="/styles.c538bfc6.css"/><link rel="stylesheet" href="/styles.c538bfc6.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/palindromic-superpermutations.mdx.abdf87e1.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/palindromic-superpermutations.mdx.abdf87e1.css"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Merriweather:400,400i|Source+Code+Pro:500,500i&amp;display=swap" rel="stylesheet"/><link data-react-helmet="true" rel="alternate" type="application/rss+xml" title="tuzz.tech" href="/feed.xml"/><link data-react-helmet="true" rel="icon" href="data:;base64,iVBORw0KGgo="/><link data-react-helmet="true" rel="prev" href="/blog/adding-bash-completion"/><link data-react-helmet="true" rel="next" href="/blog/react-commentary-sidebar"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><div class="styles-layout_qpgG"><div class="styles-content_1JPb"><div style="outline:none" tabindex="-1"><div style="outline:none" tabindex="-1"><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/adding-bash-completion">← Previous</a><a href="/blog/react-commentary-sidebar">Next Article →</a></span></div><h1 class="styles-h1_3RZl">Searching for palindromic superpermutations</h1><time dateTime="2019-10-20T12:00Z">Published <!-- -->October 20, 2019<!-- --> by <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a><a href="/feed.xml" target="_blank" class="styles-feed_icon_SE8y"><svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="3.429" cy="20.571" r="3.429"></circle><path d="m11.429 24h4.57c0-8.821-7.178-15.999-15.999-16v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path><path d="m24 24c0-13.234-10.766-24-24-24v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path></svg></a></time><div class="note">This is the first of two parts. The second will be available in a couple of weeks.</div><figure class="more_space styles-figure_23Vi"><a href="/videos/chaffin-search.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/chaffin-search.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Running my Rust-powered search algorithm</span></figcaption></figure><p>A superpermutation is a string of numbers that contains every permutation of
those numbers. For example, ‘123121321’ contains all <span>six</span> permutations of three numbers:</p><aside class="styles-aside_161L">123, 231, 312, 213, 132 and 321.</aside><p>One way to construct a superpermutation is to concatenate all N! permutations
together but this is wasteful. We’d end up with a <span>string</span> of length 18 instead of 9:</p><aside class="styles-aside_161L">‘123231312213132321’</aside><p>The <em>trick</em> is to try and overlap permutations as much as possible. <span>Most</span> of the time, when we add a character this
also add a permutation, but not always. A ‘greedy’ algorithm works fairly well
to find <em>short</em> strings, but they might not be optimal.</p><aside class="styles-aside_161L">A ‘greedy’ approach is short sighted in that it picks characters that seem like good choices now but end up costing more in the long run.</aside><p>So the question is: <strong>how short can these strings be?</strong></p><p>Many people are trying to figure that out, either constructively, by
exhaustive search for the shortest string, or non-constructively, by proof of
its exact <span>length</span>. Ideally, we’d come up with
an efficient process to build the shortest possible string.</p><aside class="styles-aside_161L"><p>It might be this problem is <a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank">NP-hard</a> and no efficient process exists.</p></aside><p>I’m certainly no mathematician so I won’t tackle a proof, but I do know some
things about writing efficient search algorithms. In this article I’ll explain
my recent attempt to find <strong>minimal <span>superpermutations</span></strong> - in this case, those that happen to be
palindromes.</p><aside class="styles-aside_161L">A palindrome is a string that’s the same forwards and backwards.</aside><p>Along the way I wrote some C and Rust code. I’ll focus on the high-level
approach in this article and save a detailed walk-through of the code for the
next.</p><a href="#why-palindromes"><h3 id="why-palindromes" class="styles-h3_yb8_">Why palindromes?</h3></a><p>In general, minimal superpermutations need not be palindromes. It so <span>happens</span> for N=1 to 4 they <em>are</em>, but no one has
proved whether or not this is always true. In fact, for N=5 there are
<a href="https://raw.githubusercontent.com/superpermutators/superperm/master/superpermutations/5/153-chaffin.txt" target="_blank"><em>eight</em> shortest strings</a>
tied at 153 characters - one of which is a palindrome.</p><aside class="styles-aside_161L"><p>For N=6, no one knows! The best strings so far have 872 characters, none of
which are palindromes.</p></aside><p>I decided to limit my search to palindromes because I think there’s fair chance
the <span>shortest</span> superpermutation <em>is</em> a
palindrome and this lets us reduce the search space, making the problem more
tractable. <strong>Otherwise, the search might never finish.</strong></p><aside class="styles-aside_161L"><p>For the last few a months a <a href="http://www.supermutations.net/ChaffinMethodResults/" target="_blank">large distributed search</a>
has been trying to solve the general case for N=6.</p></aside><p>Actually, I wholly expect the search not to finish anyway - even with this
limitation. I’m going to run it for a month or two on the N=6 problem to see
how far it gets, but I have low expectations. The <a href="https://twitter.com/chrispatuzzo/status/1067403432674435072" target="_blank">combinatorial
abyss</a> is vast and
unforgiving.</p><a href="#no-repetition"><h3 id="no-repetition" class="styles-h3_yb8_">No repetition</h3></a><p>There’s one more assumption I’m going to make about minimal superpermutations.
That is: they do not contain the same permutation more than once. In other
words, each and every permutation appears exactly once in the string, with no
repetition.</p><p>Again, there’s no proof of this, but there’s mounting evidence this is the case.
For the N=6 problem, <a href="https://docs.google.com/spreadsheets/d/1m8mHizDHoDpT-9ohCiqmfKyQI6gmhuyuzb7TC7362Ko/edit#gid=0" target="_blank">more than ten
thousand</a>
strings have been found with the shortest known length of 872. As far as I’m
aware none of these repeat a permutation.</p><p>With <span>this</span> assumption in place, we can prune
strings from our search that contain repetition - reducing the search space.
This improves our chances of success.</p><aside class="styles-aside_161L">It might seem arbitrary to do this. We’ll see shortly how the benefits of this assumption are compounded when searching for palindromes.</aside><a href="#how-it-works"><h2 id="how-it-works" class="styles-h2_13mz">How it works</h2></a><p>At a high level, the algorithm works by searching for the shortest string that
contains exactly half the permutations. This string must also have the special
property that its reversal contains precisely the <em>other half</em> of the
permutations (the ones it’s missing).</p><p>When this string is <span>glued</span> together with its
reversal, it forms a palindrome that is a superpermutation - a string that
contains all N! permutations.</p><aside class="styles-aside_161L">We overlap the last character of the string with the first of its reversal.</aside><p>For example, ‘12312’ contains 123, 231 and 312 which are three of the six
permutations for N=3. Its reversal ‘21321’ contains 213, 132 and 321 which are
precisely the <em>other three</em> permutations it’s missing so it has the property we
want.</p><p>That means we can glue ‘12312’ and ‘21321’ together to obtain <span>‘123121321’</span> which now contains all N! permutations - making
a (palindromic) superpermutation.</p><aside class="styles-aside_161L">We overlap the ‘2’ in the middle.</aside><a href="#depth-first-search"><h3 id="depth-first-search" class="styles-h3_yb8_">Depth-first search</h3></a><p>The <span>search</span> is depth first, starting from the
12...N permutation. This can be thought of as the root node of a search tree.
At each step, we ‘expand’ one string by adding a single character to the end of
it. This adds a child node to the search tree.</p><aside class="styles-aside_161L">The code doesn’t explicitly build a search tree. It manifests itself through recursive function calls. I just find it useful to think in this way.</aside><p>From Wikipedia: “A depth-first search explores as far as possible along each
branch before backtracking.” When we translate that definition to this problem,
it means we should expand longer and longer strings before backtracking to
expand shorter ones:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-bash"><code class="prism-code language-bash"><span class="token-line"><span class="token plain">                </span><span class="token number">1234</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">                /  </span><span class="token punctuation">\</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">             </span><span class="token number">12341</span><span class="token plain">  </span><span class="token punctuation">(</span><span class="token plain">not expanded yet</span><span class="token punctuation">)</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">             /</span></span><span class="token-line"><span class="token plain">          </span><span class="token number">123412</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">          /</span></span><span class="token-line"><span class="token plain">      </span><span class="token number">1234121</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">       /</span></span><span class="token-line"><span class="token plain">     </span><span class="token punctuation">..</span><span class="token plain">.</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A depth-first search starting from the ‘1234’ root node</p></span></figcaption></figure><aside class="styles-aside_161L"><p><strong>Why depth-first search?</strong></p><p>The main reason is to find long strings early on in the search to learn about
the problem’s structure.</p><p>We’ll see in the ‘Chaffin’ section how to use these learnings to our advantage
to speed up the search.</p><p>In other projects, I’ve tried different algorithms
(<a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank">A*</a>,
reduction to <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" target="_blank">SAT</a>) which I
might write about later.</p></aside><p>There’s still the question of when to backtrack. This is where our ‘No repeats’
assumption comes into play. When a string is expanded, we check:</p><ol><li>Is the tail of the string a permutation?</li><li>If so, have we seen it before?</li></ol><p>If the answer is <em>yes</em> we <span>backtrack</span>. There’s
no point expanding the string further since we’re not interested in
superpermutations that contain repetition.</p><aside class="styles-aside_161L">Backtracking is really good! It eliminates regions of search space that can’t possibly bear fruit.</aside><a href="#the-magic"><h3 id="the-magic" class="styles-h3_yb8_">The magic</h3></a><p>However, we can go one step further! We know we’re going to glue this string to
its reversal. That means <strong>all permutations seen so far will be seen again</strong> -
but in reverse. Our assumption is each permutation appears once in the
<em>entirety</em> of the string.</p><p>That means <strong>we can check the tail of the string a second time</strong>. If we’ve seen
its reversal before we can backtrack as well. This pre-empts the repetition
that <em>would occur</em> when the string is glued later. This lets us eliminate even
more <span>strings!</span></p><aside class="styles-aside_161L">We can see the future.</aside><p>Here’s what the code might look like:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-rust"><code class="prism-code language-rust"><span class="token-line"><span class="token keyword">if</span><span class="token plain"> permutations_seen</span><span class="token punctuation">[</span><span class="token plain">tail_of_string</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// backtrack</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">tail_of_string</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">if</span><span class="token plain"> permutations_seen</span><span class="token punctuation">[</span><span class="token plain">tail_of_string</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// backtrack</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Backtracking if we’ve seen the tail of string in reverse</p></span></figcaption></figure><aside class="styles-aside_161L"><p>In Rust, the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reverse" target="_blank"><code class="prism-code language-none"><span class="token-line"><span class="token plain">.reverse()</span></span></code></a> function mutates in place.</p></aside><p>I think of this as the <em>magic</em> of this approach. It’s this combination of ideas
that initially motivated me to try writing the search algorithm. Whether or not
it makes a significant dent in the problem remains to be seen but it’s worth a
shot.</p><p>Finally, there’s one last piece we need to supercharge the search algorithm.</p><a href="#the-chaffin-method"><h2 id="the-chaffin-method" class="styles-h2_13mz">The ‘Chaffin’ method</h2></a><p>The search incorporates a clever technique devised by Benjamin Chaffin. The
basic idea is to break the problem into a <span>sequence</span> of subproblems. We can then use the solution to
the first subproblem to speed up solving the second, and so on.</p><aside class="styles-aside_161L"><p>This is an example of <a href="https://en.wikipedia.org/wiki/Incremental_heuristic_search" target="_blank">incremental heuristic search</a>.</p></aside><p>Each subproblem is stated in terms of ‘wasted’ characters. A wasted character
is one that doesn’t add a new permutation itself but instead, prepares the
string so the next character can add a permutation. Sometimes more than one in a
row is needed.</p><p>For <span>example</span>, when ‘1’ is appended to ‘12312’
we get ‘123121’. The ‘1’ character is deemed <em>wasted</em> because it doesn’t add a
new permutation to the string. It does however prepare the string for a
subsequent ‘3’ which adds the 213 permutation.</p><aside class="styles-aside_161L">The term ‘wasted’ is a bit harsh since the character is useful, it just doesn’t add a new permutation.</aside><p>Now that we understand wasted characters, subproblems are defined as:</p><blockquote><p>How many permutations can fit into a string that has W wasted characters?</p></blockquote><p>The <span>algorithm</span> starts by solving the W=0 case
by depth-first search. It enumerates all strings that do not waste any
characters and counts how many permutations appear in them. The maximal count
of permutations is the solution of the subproblem.</p><aside class="styles-aside_161L">For W=0, the solution is always equal to N since that’s the longest string before we hit a cycle: ‘12312’</aside><a href="#climbing-a-ladder"><h3 id="climbing-a-ladder" class="styles-h3_yb8_">Climbing a ladder</h3></a><p>The algorithm proceeds to solve the W=1 subproblem, using the solution of W=0 to
speed up the search. <span>This</span> works by pruning
strings that can’t possibly produce a maximal count of permutations because
they’ve already wasted too many characters.</p><aside class="styles-aside_161L"><p>This is an example of <a href="https://en.wikipedia.org/wiki/Branch_and_bound" target="_blank">branch and
bound</a>.</p></aside><p>For <span>example</span>, when solving W=1, if we’ve seen
‘12312132’ which contains five permutations, there’s no point expanding ‘1232’
because we know from W=0 this string is doomed to failure. It can’t possible
beat the string with five permutations.</p><aside class="styles-aside_161L">‘1232’ contains one permutation and wastes one character. In the best case, W=0 tells us we can add three permutations, totalling four.</aside><p>We then proceed to solve W=2, W=3 and so on. At each step we refer back to all
previous solutions to prune the search. The code looks something like this:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-rust"><code class="prism-code language-rust"><span class="token-line"><span class="token keyword">let</span><span class="token plain"> surplus_waste </span><span class="token operator">=</span><span class="token plain"> W </span><span class="token operator">-</span><span class="token plain"> current_waste</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> max_perms </span><span class="token operator">=</span><span class="token plain"> subproblem_solutions</span><span class="token punctuation">[</span><span class="token plain">surplus_waste</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">let</span><span class="token plain"> best_perms </span><span class="token operator">=</span><span class="token plain"> current_perms </span><span class="token operator">+</span><span class="token plain"> max_perms</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">if</span><span class="token plain"> best_perms </span><span class="token operator">&lt;=</span><span class="token plain"> </span><span class="token operator">*</span><span class="token plain">best_seen_so_far </span><span class="token punctuation">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// prune this string</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Pruning strings by using solutions to previous subproblems</p></span></figcaption></figure><aside class="styles-aside_161L"><p><code class="prism-code language-none"><span class="token-line"><span class="token plain">*best_seen_so_far</span></span></code> points to a value shared across all branches of the
search. If we <a href="https://www.mathwarehouse.com/programming/passing-by-value-vs-by-reference-visual-explanation.php" target="_blank">passed by
value</a>,
neighbors wouldn’t see changes and we’d miss opportunities to prune.</p></aside><p>A <span>(contrived)</span> analogy is to imagine
climbing a ladder. The search algorithm is working on one of the rungs and is
supported by preceding rungs to get its job done.</p><aside class="styles-aside_161L"><p>contrived != helpful</p></aside><p>The addition of Chaffin’s method has a dramatic impact on the effectiveness of
the <span>search</span>. For N=5, the search completes
almost instantly. Without this code, it grinds to a halt. It would likely take
a <em>very</em> long time to finish the search.</p><aside class="styles-aside_161L"><p>I first read about Chaffin’s method in
<a href="http://www.njohnston.ca/2014/08/all-minimal-superpermutations-on-five-symbols-have-been-found/" target="_blank">this article</a> by Nathaniel Johnston.</p></aside><a href="#onwards"><h3 id="onwards" class="styles-h3_yb8_">Onwards</h3></a><p>In part two I’ll walk through the code and go into much more detail about how
the algorithm <em>actually</em> works. I haven’t written part two yet so check back
in a couple of weeks. I’ll also announce its publication
<a href="https://twitter.com/chrispatuzzo" target="_blank">on Twitter</a>.</p><p>If you can’t wait, the <span>latest</span> iteration of
my (scrappy) code is <a href="https://github.com/tuzz/chaffin-variation-rust-v2" target="_blank">here</a>.</p><aside class="styles-aside_161L"><p>There’s also
<a href="https://github.com/tuzz/chaffin-variation" target="_blank">this</a> and
<a href="https://github.com/tuzz/chaffin-variation-rust" target="_blank">this</a>.</p></aside><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/adding-bash-completion">← Previous</a><a href="/blog/react-commentary-sidebar">Next Article →</a></span></div></div></div></div></div><div class="styles-footer_1oSO"><p>© <!-- -->2020<!-- --> <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a></p></div></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/app/pages/blog/palindromic-superpermutations.mdx\",\"sharedHashesByProp\":{},\"data\":{},\"path\":\"blog/palindromic-superpermutations\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/palindromic-superpermutations.mdx.e4d75d06.js"></script><script defer="" type="text/javascript" src="/templates/styles.f5f0f4b2.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.abecbdad.js"></script><script defer="" type="text/javascript" src="/main.4c9105b0.js"></script></body></html>