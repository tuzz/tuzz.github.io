<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Grappling with infinity in constraint solvers - tuzz.tech</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1.0"/><meta data-react-helmet="true" name="author" content="Chris Patuzzo"/><meta data-react-helmet="true" property="og:title" content="Grappling with infinity in constraint solvers"/><meta data-react-helmet="true" property="og:url" content="https://tuzz.tech/blog/grappling-with-infinity"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:description" content="How can we solve constraint-satisfaction problems that deal with infinite structure? This article is about Sentient, a programming language I wrote to solve tricky problems."/><meta data-react-helmet="true" name="description" content="How can we solve constraint-satisfaction problems that deal with infinite structure? This article is about Sentient, a programming language I wrote to solve tricky problems."/><meta data-react-helmet="true" name="keywords" content="Chris Patuzzo,Constraint programming,Constraint solvers,Sentient,Infinity,Approximations,SAT,Satisfiability,NP-hard,Turing completeness,Loop unrolling"/><meta data-react-helmet="true" property="og:image" content="https://tuzz.tech/images/multi-dimensional-space.png"/><meta data-react-helmet="true" property="og:image:secure_url" content="https://tuzz.tech/images/multi-dimensional-space.png"/><meta data-react-helmet="true" property="og:image:width" content="1556"/><meta data-react-helmet="true" property="og:image:height" content="1018"/><meta data-react-helmet="true" property="og:video" content="https://tuzz.tech/videos/sum-of-squares-optimisation.mp4"/><meta data-react-helmet="true" property="og:video:secure_url" content="https://tuzz.tech/videos/sum-of-squares-optimisation.mp4"/><meta data-react-helmet="true" property="og:image:type" content="video/mp4"/><meta data-react-helmet="true" property="og:video:width" content="1218"/><meta data-react-helmet="true" property="og:video:height" content="700"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/app/pages/blog/grappling-with-infinity.mdx.c089acb2.js"/><link rel="preload" as="script" href="/templates/styles.f5f0f4b2.js"/><link rel="preload" as="script" href="/templates/vendors~main.abecbdad.js"/><link rel="preload" as="script" href="/main.4c9105b0.js"/><link rel="preload" as="style" href="/main.6c84323b.css"/><link rel="stylesheet" href="/main.6c84323b.css"/><link rel="preload" as="style" href="/styles.c538bfc6.css"/><link rel="stylesheet" href="/styles.c538bfc6.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.0295268c.css"/><link rel="preload" as="style" href="/__react_static_root__/app/pages/blog/grappling-with-infinity.mdx.abdf87e1.css"/><link rel="stylesheet" href="/__react_static_root__/app/pages/blog/grappling-with-infinity.mdx.abdf87e1.css"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Merriweather:400,400i|Source+Code+Pro:500,500i&amp;display=swap" rel="stylesheet"/><link data-react-helmet="true" rel="alternate" type="application/rss+xml" title="tuzz.tech" href="/feed.xml"/><link data-react-helmet="true" rel="icon" href="data:;base64,iVBORw0KGgo="/><link data-react-helmet="true" rel="prev" href="/blog/react-commentary-sidebar-2"/><link data-react-helmet="true" rel="next" href="/blog/pair-programming-in-sentient"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><div class="styles-layout_qpgG"><div class="styles-content_1JPb"><div style="outline:none" tabindex="-1"><div style="outline:none" tabindex="-1"><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/react-commentary-sidebar-2">← Previous</a><a href="/blog/pair-programming-in-sentient">Next Article →</a></span></div><h1 class="styles-h1_3RZl">Grappling with infinity in constraint solvers</h1><time dateTime="2019-11-17T12:00Z">Published <!-- -->November 17, 2019<!-- --> by <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a><a href="/feed.xml" target="_blank" class="styles-feed_icon_SE8y"><svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="3.429" cy="20.571" r="3.429"></circle><path d="m11.429 24h4.57c0-8.821-7.178-15.999-15.999-16v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path><path d="m24 24c0-13.234-10.766-24-24-24v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path></svg></a></time><span></span><div class="note"><p>In 2016, I created a programming language called
<a href="https://sentient-lang.org/" target="_blank">Sentient</a>. Since then, I’ve had time to reflect and
think about the language. This series is about that.</p></div><p>Many constraint-satisfaction problems deal with infinity in some shape or form.
Even rudimentary problems, like &quot;Find two integers that sum to 10&quot;. Solutions include:</p><ul><li>(4, 6)</li><li>(-7, 17)</li><li>(-1953856112, <span>1953856122)</span></li></ul><aside class="styles-aside_161L"><p>That (d)escalated quickly!</p></aside><p>In fact, there are infinitely many solutions and infinitely many pairs of
integers to test. Here’s a <a href="https://sentient-lang.org/" target="_blank">Sentient</a> program to
solve this problem:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a, b</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a + b == </span><span class="token number">10</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a, b</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A Sentient program to find integers that sum to 10</p></span></figcaption></figure><aside class="styles-aside_161L"><p>This article is about Sentient, but many of the concepts apply to constraint solvers in general.</p></aside><p>We can run this with the <a href="https://sentient-lang.org/cli/number" target="_blank"><code class="prism-code language-none"><span class="token-line"><span class="token plain">--number 0</span></span></code> option</a>,
to continuously find solutions:</p><span></span><figure class="undefined styles-figure_23Vi"><a href="/videos/sentient-sum-to-ten.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/sentient-sum-to-ten.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Finding multiple solutions with Sentient</span></figcaption></figure><aside class="styles-aside_161L"><p>When Sentient returns <code class="prism-code language-none"><span class="token-line"><span class="token plain">{}</span></span></code>, it has exhausted the search space and can’t find any
more solutions.</p></aside><p>After a few seconds this <span>program</span> terminates
which seems <em>wrong</em>. Why should a problem that has infinitely many solutions
ever terminate? Shouldn’t it run forever?</p><aside class="styles-aside_161L"><p>I sometimes use ‘program’ and ‘problem’ synonymously. Programs are descriptions of problems.</p></aside><p>The simple answer is that integers in Sentient aren’t really integers as far as
the mathematical definition is concerned. Their magnitude is limited by how
many bits represent them. By <span>default</span> this is
8 but can be specified, e.g. <code class="prism-code language-none"><span class="token-line"><span class="token plain">int9</span></span></code>, <code class="prism-code language-none"><span class="token-line"><span class="token plain">int32</span></span></code></p><aside class="styles-aside_161L"><p><code class="prism-code language-none"><span class="token-line"><span class="token plain">int</span></span></code> ranges from -128 to 127.</p></aside><p>In many cases this is fine. We can pick a number of bits that’s ‘big enough’
and not worry about it. But other times it’s not fine. We often want to start
small and work our way up to larger representations, but that means restarting
the program each time.</p><p>For some problems, solutions are extremely rare (or non-existent) and it could
take weeks or months for <span>Sentient</span> to find
one. In these cases, it makes sense to start with small representations and
progressively rule our search spaces of increasing size.</p><aside class="styles-aside_161L"><p>A negative result for a small space is better than no result for a larger one.</p></aside><p>Unfortunately, when a program is restarted, we lose its progress. Regions that
were already explored are explored again. If we increase <code class="prism-code language-none"><span class="token-line"><span class="token plain">int</span></span></code> to <code class="prism-code language-none"><span class="token-line"><span class="token plain">int9</span></span></code>,
Sentient finds new solutions but it also finds all the same solutions again.
This is wasteful.</p><p>We could compensate by adding a constraint:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int9</span><span class="token plain"> a, b</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a &lt; </span><span class="token number">-128</span><span class="token plain"> || a &gt; </span><span class="token number">127</span><span class="token plain"> || b &lt; </span><span class="token number">-128</span><span class="token plain"> || b &gt; </span><span class="token number">127</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token comment"># ...</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Eliminating the region we’ve already explored</p></span></figcaption></figure><p>But <span>this</span> becomes unwieldy, and for many
problems, isn’t easy to specify. It’s also a manual process and therefore
error-prone. Ideally, Sentient would offer first-class support for something
like this. I have some ideas about how that might work.</p><aside class="styles-aside_161L"><p>This specifies that <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> or <code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code> must lie outside the region already explored for
eight-bit integers.</p></aside><aside class="styles-aside_161L"><p>In <a href="https://github.com/tuzz/letterwise_magic_squares/blob/master/lib/letterwise_magic_squares/generator.rb" target="_blank">some cases</a>, I’ve
<a href="https://github.com/tuzz/number_chains/blob/master/lib/number_chain/generator.rb" target="_blank">written scripts</a>
to generate Sentient programs with integers of increasing size.</p></aside><a href="#approximations"><h2 id="approximations" class="styles-h2_13mz">Approximations</h2></a><p>I’ve <span>found</span> a useful way to think about this
is in terms of <em>approximations</em>. An eight-bit integer is really an
approximation of the mathematical (infinite) version of an integer. Its domain
is finite but as long as we stay within bounds, it behaves in the same way.</p><aside class="styles-aside_161L"><p>I’m using ‘approximation’ in a <em>literal</em> sense and not according to some precise
mathematical definition.</p></aside><p>Most of the time when we write computer programs we don’t have to think about
this because we deal with concretions. Variables are assigned concrete values
and, provided we stay within range without overflowing, everything checks out.</p><p>In our case, variables are <span>‘symbolic’</span>. We
don’t actually assign values to <code class="prism-code language-none"><span class="token-line"><span class="token plain">int a, b</span></span></code>, we just tell Sentient they exist and
specify some constraints. Its job is to discover values for <code class="prism-code language-none"><span class="token-line"><span class="token plain">a, b</span></span></code>, but it has
to work with something tangible. It can’t reason about infinity.</p><aside class="styles-aside_161L"><p>‘Symbolic’ is the term used by the <a href="https://klee.github.io/" target="_blank">KLEE</a> project for
this concept.</p></aside><p><strong>Why <span>can’t</span> Sentient reason about infinity?</strong></p><aside class="styles-aside_161L"><p>Great question!</p></aside><p>Technically it could but currently, its implementation closely relates to the
mechanism it uses for solving. Programs are compiled to instances of
<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" target="_blank">SAT</a> which, by
definition, are boolean equations that comprise finitely many variables and
clauses.</p><p>This <span>doesn’t</span> have to be the case, though.
Sentient could abstract over these equations and automatically introduce new
variables to represent larger integers.</p><aside class="styles-aside_161L"><p>I think of this as <em>better approximating</em> the infinite version of an integer.</p></aside><p>Actually, <span>Sentient</span> does something similar to
this for the <a href="https://sentient-lang.org/cli/number" target="_blank"><code class="prism-code language-none"><span class="token-line"><span class="token plain">--number</span></span></code> option</a>.
Sentient finds multiple solutions to problems by repeatedly solving the same
equation. It introduces a new clause each time to ban the solution it just
found.</p><aside class="styles-aside_161L"><p>Sentient doesn’t solve these equations itself. It delegates to SAT solvers,
such as <a href="http://fmv.jku.at/lingeling/" target="_blank">lingeling</a>.</p></aside><p><strong>Could we dynamically change the size of representations?</strong></p><p>We could, but it’s not obvious how to do this. If a program declares multiple
integers, should we change their number of bits all at once or one by one? For
example, should we increase <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code> to <code class="prism-code language-none"><span class="token-line"><span class="token plain">int9</span></span></code> in one go, or <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> followed by
<code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code> ?</p><p>For some problems, there could by differences in magnitude that are important:</p><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a, b</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token cdata">int15</span><span class="token plain"> target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a * b == target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a, b, target</span><span class="token punctuation">;</span></span></code></pre></div><p>This <span>program</span> contains implicit knowledge
that multiplying two numbers in the range -128 to 127 results in a number in
the range -16,384 to 16,383. Every time we increase <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code>’s
representation by one bit we <em>should probably</em> increase <code class="prism-code language-none"><span class="token-line"><span class="token plain">target</span></span></code>’s by two.</p><aside class="styles-aside_161L"><p>Technically, we should use <code class="prism-code language-none"><span class="token-line"><span class="token plain">int16</span></span></code> because -128 x -128 is 16,384 which lies just
outside -2^14 to 2^14 - 1.</p></aside><p>What’s more, we haven’t considered more complex cases. What about arrays of
integers or arrays of arrays? We also need to consider how Sentient
communicates where it’s up to. Which regions of search space has it exhausted so
far?</p><a href="#more-infinity"><h3 id="more-infinity" class="styles-h3_yb8_">More infinity</h3></a><p>Before we try to answer some of these questions, let’s first consider other
places infinity might crop up. There’s an
<a href="https://www.youtube.com/watch?v=wymmCdLdPvM&amp;list=PLt5AfwLFPxWJcqG5YM89Qes5gZdAFM4Q1" target="_blank">excellent series</a>
on <span>Numberphile</span> about the problem of finding
three cubes that sum to a target number. Let’s use that to help reason.</p><aside class="styles-aside_161L"><p>Brady also talks about this problem to in <a href="https://www.youtube.com/watch?v=7Bia-dNcBm4" target="_blank">this video</a> with Adam Savage.</p></aside><p>Here’s a Sentient program to solve this problem:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a, b, c, target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a.cube + b.cube + c.cube == target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a, b, c, target</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A program to find three cubes that sum to a target</p></span></figcaption></figure><aside class="styles-aside_161L"><p>We could hardcode <code class="prism-code language-none"><span class="token-line"><span class="token plain">target</span></span></code>, but this makes the program more general. We can
<a href="https://sentient-lang.org/cli/assign" target="_blank">assign its value</a> at runtime.</p></aside><p>Firstly, let’s say we want to generalise our program further. Instead of summing
three cubes together, it’d be nice if we were able to write a program that sums
<code class="prism-code language-none"><span class="token-line"><span class="token plain">N</span></span></code> cubes. We could assign <code class="prism-code language-none"><span class="token-line"><span class="token plain">N</span></span></code> at runtime if we want or leave it unspecified.</p><p>This isn’t valid syntax, but such a program might look like:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token plain">array&lt;</span><span class="token cdata">int</span><span class="token plain">&gt; numbers</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token cdata">int</span><span class="token plain"> target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> numbers.map(</span><span class="token function">*cube</span><span class="token plain">).sum == target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> numbers, target</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A program to find <code class="prism-code language-none"><span class="token-line"><span class="token plain">N</span></span></code> cubes that sum to a target</p></span></figcaption></figure><aside class="styles-aside_161L"><p>This isn’t valid because you have to specify the size of an array, e.g.</p><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">array3</span><span class="token plain">&lt;</span><span class="token cdata">int</span><span class="token plain">&gt; numbers</span><span class="token punctuation">;</span></span></code></pre></div></aside><p>Furthermore, why should the exponent be fixed? It’d be wonderful if that too
could be assigned at runtime or left unspecified for an extra degree of freedom.</p><p>That program might look like this:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token plain">array&lt;</span><span class="token cdata">int</span><span class="token plain">&gt; numbers</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token cdata">int</span><span class="token plain"> target, exp</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> numbers.map(</span><span class="token function">*pow</span><span class="token plain">, exp).sum == target</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> numbers, target, exp</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A program to find <code class="prism-code language-none"><span class="token-line"><span class="token plain">N</span></span></code> numbers raised to an exponent that sum to a target</p></span></figcaption></figure><aside class="styles-aside_161L"><p>This deviates further from Sentient’s syntax as <code class="prism-code language-none"><span class="token-line"><span class="token plain">map</span></span></code> doesn’t support passing
args to function pointers, but hopefully you get the idea.</p></aside><p>Perhaps this is too generic, but consider this: In just four lines, we’d be
able to write a program that can solve a broad class of
<a href="https://en.wikipedia.org/wiki/Diophantine_equation" target="_blank">diophantine equations</a>.
I find this <span>tantalising</span>. It would be a triumph
of our ability to communicate intention to the machine.</p><aside class="styles-aside_161L"><p>But can it be realised?</p></aside><p><strong>How does this fit with approximations?</strong></p><p>If we consider these cases in the context of approximation, a fixed-size array
could be seen as an approximation of a general array of unlimited size. We could
approximate a general array by running multiple versions of our program with
different sizes.</p><p>There <span>are</span> infinitely many array sizes to try
and infinitely many exponents. These cases differ slightly from before because
there’s no overlap in search space. Nine-bit integers <em>contain</em> all the
eight-bit integers, but ‘squares’ and ‘cubes’ are <em>distinct</em> problems.</p><aside class="styles-aside_161L"><p>Some approximations result in containment hierarchies, others define independent
spaces.</p></aside><a href="#multi-dimensional-space"><h2 id="multi-dimensional-space" class="styles-h2_13mz">Multi-dimensional space</h2></a><p>For each of these approximations, we can think of them as defining a dimension
in space. For example, here’s a two-dimensional space for integers <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code>:</p><span></span><figure class="undefined styles-figure_23Vi"><a href="/images/multi-dimensional-space.png" target="_blank"><img src="/images/multi-dimensional-space.png" alt="Multi-dimensional space"/></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Visualising approximations as dimensional space</span></figcaption></figure><p>The <span>highlighted</span> point is an instance of a
Sentient program with integers <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> and <code class="prism-code language-none"><span class="token-line"><span class="token plain">b</span></span></code> approximated with nine and eight
bits, respectively. The shaded region shows the space being considered which
includes integers with fewer bits. The axes go to infinity.</p><aside class="styles-aside_161L"><p>For approximations with distinct search spaces, there wouldn’t be a shaded
region - just a point or a line.</p><p>Integer approximations define regions because <code class="prism-code language-none"><span class="token-line"><span class="token plain">int9</span></span></code> contains <code class="prism-code language-none"><span class="token-line"><span class="token plain">int</span></span></code>, <code class="prism-code language-none"><span class="token-line"><span class="token plain">int7</span></span></code>,
<code class="prism-code language-none"><span class="token-line"><span class="token plain">int6</span></span></code>, etc.</p></aside><aside class="styles-aside_161L"><p>The size of <em>this</em> space isn’t representative of the search space which doubles
in size each time we add a single bit to an approximation.</p></aside><p>Each time we approximate an integer, this adds a new dimensions to our space. If
we run a Sentient program multiple times with different approximations, we can
think of this as defining a walk or a path through this multi-dimensional space.</p><a href="#infinite-dimensional-space"><h3 id="infinite-dimensional-space" class="styles-h3_yb8_">Infinite-dimensional space</h3></a><p>Our extremely general program above contains this line:</p><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token plain">array&lt;</span><span class="token cdata">int</span><span class="token plain">&gt; numbers</span><span class="token punctuation">;</span></span></code></pre></div><p>Here there are two kinds of infinity. Arrays can have unlimited size and
integers can be arbitrarily large. This is problematic because we first need to
approximate the size of the array and then approximate the integers within that
array.</p><p>The result of these two degrees of freedom is an infinite dimensional space
with a dimension for every possible size of array. The nth dimension in this
space defines how many bits are used to approximate the integer at position n in
the array.</p><p>As we add more approximations, these spaces are compounded and this
spatial <span>metaphor</span> starts to fall apart. I’m
not sure whether it’s useful to think about approximations in this way when we
go above a small number of dimensions.</p><aside class="styles-aside_161L"><p>My head hurts when I think about arrays of arrays of integers.</p></aside><a href="#incrementality"><h2 id="incrementality" class="styles-h2_13mz">Incrementality</h2></a><p>Now let’s turn back to the question of how to change approximations over time.
There doesn’t seem to be an obvious approach other than something naive like
<a href="https://whatis.techtarget.com/definition/round-robin" target="_blank">round-robin</a>.
Approximations with overlapping / non-overlapping spaces complicate things
further.</p><p>It seems to me the most robust way to do this is to delegate these decisions to
the programmer. <span>Define</span> a <em>protocol</em> so that
a program can determine how approximations should change at various stages
during the search.</p><aside class="styles-aside_161L"><p>This program could even ask for user-input to decide what to do.</p></aside><p>For example, our program that &quot;finds two integers that sum to ten&quot; could
initially call an external program that instructs it how many bits to use for
its approximations. <span>Once</span> the search space is
exhausted, it could ask the program what to do next:</p><aside class="styles-aside_161L"><p>Or it could ask at time intervals, or after each solution is found.</p></aside><span></span><figure class="undefined styles-figure_23Vi"><a href="/images/approximation-protocol.png" target="_blank"><img src="/images/approximation-protocol.png" alt="A protocol for approximation"/></a><figcaption><span class="styles-arrow_2C7-">▲</span><span>Using an external program to decide how approximations should change</span></figcaption></figure><aside class="styles-aside_161L"><p>Sentient could send additional information to the program such as:</p><ul><li>the solutions that were found and how long it took</li><li>the impact on the search space of each approximation</li><li>whether approximations have overlapping spaces or not</li></ul></aside><p>The <span>protocol</span> could even allow Sentient to
spawn new processes and search distinct spaces in parallel. For example, it
could search for solutions to the ‘squares’ and ‘cubes’ problems concurrently
while controlling approximations in each instance.</p><aside class="styles-aside_161L"><p>Historically, <a href="https://dl.acm.org/citation.cfm?id=2901028" target="_blank">it’s been difficult</a>
to efficiently parallelise SAT solving so this strategy could work well.</p></aside><a href="#incremental-sat"><h3 id="incremental-sat" class="styles-h3_yb8_">Incremental SAT</h3></a><p>In the world of SAT solving, a mechanism already exists for communicating with
a <span>solver</span> during its search. It’s called the
‘Re-entrant Incremental Satisfiability Application Program Interface’ and is
referred to by its reverse acronym ‘IPASIR’.</p><aside class="styles-aside_161L"><p>IPASIR was first introduced in section 6.2 of <a href="http://fmv.jku.at/papers/BalyoBiereIserSinz-AI-16.pdf#page=9" target="_blank">this paper</a>.</p></aside><p>In fact, I wrote <a href="https://github.com/tuzz/ipasir-sys" target="_blank">a Rust crate</a> not too
long ago for communicating via this interface. The advantage of using it is to
speed up solving problems that have been modified in small ways without having
to restart the search from scratch each time:</p><blockquote><p>It is possible to solve such problems independently, however this might be
very inefficient compared to an incremental SAT solver, which can reuse
knowledge acquired while solving the previous instances.
<!-- --> <em>– <a href="http://fmv.jku.at/papers/BalyoBiereIserSinz-AI-16.pdf#page=9" target="_blank">SAT Race 2015</a> (abbreviated)</em></p></blockquote><p>At present, Sentient doesn’t use IPASIR at all. It was fairly new when I wrote
the language but has wider adoption today. At the very least, it would speed up
searching for multiple solutions to problems, but I think it could help with
approximations, too.</p><p>Ideally, <span>a</span> single instance of a SAT problem
would live for the duration of a Sentient program. As approximations change, so
too would the underlying boolean equation. That would allow a maximal amount of
information or ‘knowledge’ to be reused.</p><aside class="styles-aside_161L"><p>In theory, this would mean overlapping search spaces aren’t explored more than once.</p></aside><a href="#representations"><h3 id="representations" class="styles-h3_yb8_">Representations</h3></a><p>There <span>are</span> limitations on what you can do
with IPASIR, otherwise it would be very difficult for solvers to reuse
knowledge from previous searches. For example, you can’t remove clauses but you
can instead make ‘assumptions’ that are short-lived.</p><aside class="styles-aside_161L"><p>You can <em>effectively</em> remove clauses using assumptions by adding one to each
clause you want to remove.</p></aside><p>Some thought would need to go into how to represent approximations in a way
that allows them to change later. If we go from <code class="prism-code language-none"><span class="token-line"><span class="token plain">int</span></span></code> to <code class="prism-code language-none"><span class="token-line"><span class="token plain">int9</span></span></code>, we don’t want
to have to throw everything out. It should be possible for approximations to
‘grow’ or ‘shrink’.</p><p>All of the operations we apply to integers need to be able to cope with a
changing <span>number</span> of bits. For example,
integer addition is modelled after <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Ripple-carry_adder" target="_blank">ripple-carry
adders</a>.
Its clauses in the boolean equation would need to use assumptions in clever
ways.</p><aside class="styles-aside_161L"><p>I need to put way more thought into how this would work.</p></aside><p>It may even be there are efficiency gains if we know in advance <em>how</em>
approximations will change. If they only ever grow, and by precisely two bits
each time, perhaps there’s a more efficient way to structure these equations.
I’m not sure.</p><a href="#np-hard-problems"><h3 id="np-hard-problems" class="styles-h3_yb8_">NP-hard problems</h3></a><p>One final thought about incrementality is it would allow Sentient to reach the
dizzying heights of being able to solve
<a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank">NP-hard</a> problems. At present,
Sentient can’t solve optimisation problems. It doesn’t specifically search for
<em>minimums</em> or <em>maximums</em>.</p><p>However, <span>you</span> can <em>effectively</em> do this by
running the same program multiple times. For example, let’s say you want to
find two numbers that sum to ten such that the sum of their squares is
minimised. You could write a program like this:</p><aside class="styles-aside_161L"><p>This isn’t an NP-hard problem since it can be solved with linear algebra but it demonstrates the point.</p></aside><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a, b, max</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">sum = a.square + b.square</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a + b == </span><span class="token number">10</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> sum &lt; max</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a, b, sum, max</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Solving an optimisation problem with Sentient</p></span></figcaption></figure><aside class="styles-aside_161L"><p>A more realistic optimisation problem would be
<a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank">Travelling Salesman</a>
or the <a href="https://en.wikipedia.org/wiki/Knapsack_problem" target="_blank">Knapsack</a> problem.</p></aside><p>You could then run this multiple times, reducing <code class="prism-code language-none"><span class="token-line"><span class="token plain">max</span></span></code> until there are no
solutions:</p><span></span><figure class="undefined styles-figure_23Vi"><a href="/videos/sum-of-squares-optimisation.mp4" target="_blank"><video muted="" autoplay="" playsinline="" loop=""><source src="/videos/sum-of-squares-optimisation.mp4" type="video/mp4"/></video></a><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Finding the optimal solution over repeated runs</p></span></figcaption></figure><aside class="styles-aside_161L"><p>This finds the optimal solution <code class="prism-code language-none"><span class="token-line"><span class="token plain">{ a: 5, b: 5 }</span></span></code> whose sum of squares is 50
which is minimal.</p><p>The video is sped up slightly.</p></aside><p>I’m not sure whether my definition of approximations extends to optimisation
problems but there’s definitely an opportunity to use incrementality in a
number of useful ways.</p><a href="#turing-completeness"><h2 id="turing-completeness" class="styles-h2_13mz">Turing-completeness</h2></a><p>While we’re on the topic of NP-hard problems, it’s probably worth saying a few
things about computability and Turing completeness. On the <a href="https://sentient-lang.org/intro/experimental" target="_blank">Sentient
website</a> I wrote this:</p><blockquote><p>In fact, Sentient isn’t Turing complete. It is a Total programming language –
it is fully decidable and does not suffer the Halting problem. That
drastically limits what it can do. For example, recursive function calls are
not supported and <span>never</span> will be.</p></blockquote><aside class="styles-aside_161L"><p>Never say never!</p></aside><p>In fact, through the lens of approximations, it may be possible for Sentient to
become Turing complete. At present, Sentient doesn’t support recursive function
calls:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token function">function</span><span class="token plain"> factorial (n) </span><span class="token entity">{</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> n &gt; </span><span class="token number">0</span><span class="token plain"> ? n * factorial(n - </span><span class="token number">1</span><span class="token plain">) : </span><span class="token number">1</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token entity">}</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> a.factorial &gt; </span><span class="token number">150</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>A hypothetical Sentient program using recursion</p></span></figcaption></figure><aside class="styles-aside_161L"><p>The smallest solution is <code class="prism-code language-none"><span class="token-line"><span class="token plain">{ a: 6 }</span></span></code> because <code class="prism-code language-none"><span class="token-line"><span class="token plain">6! = 720 &gt; 150</span></span></code>.</p></aside><p>A recursive function call can be approximated by limiting its depth of
recursion. For example, if <code class="prism-code language-none"><span class="token-line"><span class="token plain">factorial</span></span></code> were approximated with a depth of 5 (or
less), it wouldn’t find a solution but improving this to 6 would. Similarly, you
can’t do this at the moment:</p><span></span><figure class="undefined styles-figure_23Vi"><div><pre class="prism-code language-sentient"><code class="prism-code language-sentient"><span class="token-line"><span class="token cdata">int</span><span class="token plain"> a</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain">sum = </span><span class="token number">0</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain">a.times(</span><span class="token function">function</span><span class="token important">^</span><span class="token plain"> () </span><span class="token entity">{</span><span class="token plain"> sum += </span><span class="token number">3</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token entity">}</span><span class="token plain">)</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">invariant</span><span class="token plain"> sum &gt; </span><span class="token number">10</span><span class="token punctuation">;</span><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span></span><span class="token-line"><span class="token plain"></span><span class="token keyword">expose</span><span class="token plain"> a</span><span class="token punctuation">;</span></span></code></pre></div><figcaption><span class="styles-arrow_2C7-">▲</span><span><p>Another hypothetical program that isn’t allowed</p></span></figcaption></figure><aside class="styles-aside_161L"><p>The <a href="https://sentient-lang.org/library/integer#times" target="_blank">#times</a> method calls the
function <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> times. It’s borrowed from Ruby.</p><p>The <code class="prism-code language-none"><span class="token-line"><span class="token plain">^</span></span></code> modifier lets the function access variables defined outside.</p></aside><p>Sentient throws an error when you try to run this program:</p><blockquote><p>Called ‘times’ with ‘a’ but ‘times’ only supports integer literals (arg #0)</p></blockquote><p>This <span>isn’t</span> supported because <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code> is
‘symbolic’. Sentient is unable to compile this program to a boolean equation
because the size of that equation can’t be determined. Its structure isn’t
fixed. The <code class="prism-code language-none"><span class="token-line"><span class="token plain">#times</span></span></code> method only works with ‘integer literals’ like <code class="prism-code language-none"><span class="token-line"><span class="token plain">5</span></span></code>.</p><aside class="styles-aside_161L">This is one of a few places where Sentient differentiates between ‘symbolic’ and ‘literal’ variables.</aside><p>Again, we could solve this problem with approximations by limiting the value
for <code class="prism-code language-none"><span class="token-line"><span class="token plain">a</span></span></code>.</p><a href="#loop-unrolling"><h3 id="loop-unrolling" class="styles-h3_yb8_">Loop unrolling</h3></a><p>This <span>technique</span> is already used in various
forms. Compilers frequently unroll loops and recursive function calls for
performance reasons.  <a href="https://en.wikipedia.org/wiki/Model_checking" target="_blank">Model
checkers</a> perform static analysis
to check invariants, often using techniques established in <a href="https://en.wikipedia.org/wiki/Hoare_logic" target="_blank">Hoare
logic</a>.</p><aside class="styles-aside_161L"><p>I was fortunate enough to see Tony Hoare at a conference which I spoke about in
episode 12 of <a href="https://makercasts.org/podcasts/my-floc-experience/" target="_blank">this podcast</a>.</p></aside><p>I see loop unrolling as another kind of approximation. Recursive functions could
be identified through static analysis and an external program could decide how
many calls are allowed for the current instance of the search.</p><p>In <span>theory</span>, these techniques would allow
Sentient to be Turing complete in a sense. This combined with incremental SAT
could make for an extremely powerful system. The ability to solve problems
relating to arbitrary Turing machines would be amazing.</p><aside class="styles-aside_161L"><p>I explored this a bit in <a href="https://github.com/tuzz/machine_maker" target="_blank">this project</a>
which reduces Turing machines to SAT, as per the
<a href="https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem" target="_blank">Cook-Levin theorem</a>.</p></aside><a href="#where-next"><h3 id="where-next" class="styles-h3_yb8_">Where next?</h3></a><p>I’m not sure. I’d like to play with these ideas more and perhaps some day
incorporate them into Sentient or something else. There are clearly challenges
with incrementality and interface design but I think I’m on the right track.</p><p>This is the first in-depth article I’ve written about Sentient and constraint
solving but hopefully there’s more to come. I’ll announce future updates
<a href="https://twitter.com/chrispatuzzo" target="_blank">on Twitter</a>
if you want to hear more. Follows are always appreciated. Thanks.</p><div class="styles-nav_bar_2D66"><span class="styles-breadcrumbs_2-AT"><a href="/blog/pair-programming-in-sentient">tuzz.tech</a><a href="/blog/pair-programming-in-sentient">blog</a></span><span class="styles-links_nqg2"><a href="/blog/react-commentary-sidebar-2">← Previous</a><a href="/blog/pair-programming-in-sentient">Next Article →</a></span></div></div></div></div></div><div class="styles-footer_1oSO"><p>© <!-- -->2020<!-- --> <!-- --> <a href="https://twitter.com/chrispatuzzo" target="_blank">Chris Patuzzo</a></p></div></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/app/pages/blog/grappling-with-infinity.mdx\",\"sharedHashesByProp\":{},\"data\":{},\"path\":\"blog/grappling-with-infinity\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/adding-bash-completion.mdx~__react_static_root__/app/pages/blog~1caefab3.c0ff43d2.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/app/pages/blog/grappling-with-infinity.mdx.c089acb2.js"></script><script defer="" type="text/javascript" src="/templates/styles.f5f0f4b2.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.abecbdad.js"></script><script defer="" type="text/javascript" src="/main.4c9105b0.js"></script></body></html>