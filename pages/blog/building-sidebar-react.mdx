import Head from "next/head";
import ImageMeta from "../../components/image_meta";
import VideoMeta from "../../components/video_meta";
import Layout from "../../components/layout";
import Aside from "../../components/aside";
import Figure from "../../components/figure";
import Frame from "../../components/frame";
import readFile from "../../helpers/read_file";
import { createRef } from "react";

export let r, r2;

export const navigation = {
  breadcrumbs: [
    { text: "tuzz.tech", href: "/" },
    { text: "blog", href: "/blog" },
  ],
  links: [
    { text: "← Previous", href: "/blog/palindromic-superpermutations" },
    { text: "Next Article →" },
  ]
};

export const title = "Building a commentary sidebar in React";
export const path = "/blog/building-sidebar-react";
export const description = "TODO";

<Head>
  <meta property="og:title" content={title} />
  <meta property="og:url" content={`https://tuzz.tech${path}`} />
  <meta property="og:description" content={description} />
  <meta property="og:type" content="article" />

  <meta name="description" content={description} />
  <meta name="keywords" content="Chris Patuzzo,TODO" />
</Head>

<Layout title={title} navigation={navigation}>

<h1>{title}</h1>

<time dateTime="2019-10-28">Published October 28, 2019 by {" "}
<a href="https://twitter.com/chrispatuzzo">Chris Patuzzo</a>
</time>

<span ref={r = createRef()} />
<span ref={r2 = createRef()} />

<!-- fourth-wall-1 -->

<Aside target={r}><p>
I'm going to break the
fourth wall in this
article! Uh oh...
</p></Aside>

<!-- fourth-wall-1 -->

<Aside target={r2} moveDown={60}><p>
<pre><code className="language-jsx">
  {readFile("pages/blog/building-sidebar-react.mdx", "fourth-wall-1")}
</code></pre>
</p></Aside>

Over the past weeks, I've been building this blog and writing articles for it.
I've spent a lot of time thinking about the reader. Who are they? Why are they
here? It's often hard to know how much detail to go into and how much background
knowledge to assume.

On the one hand, people are busy. Attentions are short and time is precious. I'd
do well to keep articles lean, focussed and to the point. But that _misses_ the
point. People are here for enjoyment and just presenting the cold hard facts
isn't going to cut it.

I've settled on an approach I hope will cater to a variety of readers. I keep
the main body of content concise and _on topic_ but enrich it with commentary on
the side. This leaves room for elaboration, tangential remarks and all the
whimsy I can <span ref={r = createRef()}>mustard</span>.

<Aside target={r}><p>
I'm so sorry.
</p></Aside>

However, this commentary hides complexity. When <span ref={r =
createRef()}>viewed</span> on a large-enough screen, it's presented in a
sidebar next to the main content. Ideally, comments sit as close as possible to
the word or phrase they refer to. This helps flow and improves continuity.

<Aside target={r}><p>
When viewed on mobile, comments are presented inside the main content but with
softer styles to show they're supplementary.
</p></Aside>

In this article, I'll explain the mechanics of how this works in my React app.
As you'll see, there's a lot to consider to make a robust, responsive and
semantic <span ref={r = createRef()}>solution</span>.

<Aside target={r}><p>
... that's SEO and print friendly.
</p></Aside>

## Structuring the DOM

Putting React to one side for a moment, let's first consider how to structure
the DOM.  HTML5 has the perfect element for our needs:

>The HTML `<aside>` element represents a portion of a document whose content is
only indirectly related to the document's main content. Asides are frequently
presented as sidebars or call-out boxes.
&nbsp;_– [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside)_

That leaves the question of whether to group all commentary together into <span
ref={r = createRef()}>a</span> single `<aside>` or to have one per comment. I
decided on the latter as I think this is more meaningful. Comments are
independent of each other so the DOM should reflect that.

<Aside target={r}><p>
It's also easier to intersperse comments with content using this approach which
is useful for mobile.
</p></Aside>

Here's how that looks in code:

<Figure>
<pre><code className="language-html">
  {readFile("public/examples/sidebar-1/index.html", "body")}
</code></pre>

Comments interspersed with content
</Figure>

### Laying things out

As you can see above, there's no DOM element for the sidebar. I think of a
sidebar as a way to present `<aside>` elements. It really ought to be a
presentational concern.

There are a number of CSS techniques we could use to create a sidebar. There's
flexbox, floats, relative and absolute positioning. This seemed simplest to
me:

<span ref={r = createRef()} />

<Figure>
<pre><code className="language-css">
  {readFile("public/examples/sidebar-1/styles.scss", "----")}
</code></pre>

One way of creating a sidebar with <span ref={r2 = createRef()}>CSS</span>
</Figure>

<Aside target={r2}>

  Technically it's [Sass](https://sass-lang.com/) as it uses nested rules.

</Aside>

<Aside target={r} moveDown={28}><p>
I've simplified this a bit. In practice there are rules to set colors, borders,
etc. There are also media queries to scale down for smaller screens.
</p></Aside>

This works by splitting the container in two. The sidebar comments live in the
space created by the `padding-right` rule. They use absolute positioning which
removes them from the document's flow and `right: 1rem` to place them in the
padded region.

We can left-position the `<aside>` elements within the sidebar by setting their
width. This is calculated as `50% - 2rem` to create the illsusion of
padding - by leaving an equal amount of space on the left and right. Here's how
it looks:

<span ref={r = createRef()} />

<Figure>
<Frame src="/examples/sidebar-1/index.html" autoScale={false} />

Using padding to create a sidebar on the right
</Figure>

<Aside target={r} moveDown={25}><p>
This is a live version of the code running in a frame. You can see a standalone
version <a href="/examples/sidebar-1/index.html" target="_blank">here</a>.
</p></Aside>

This isn't quite right because the comment is placed next to the second
paragraph instead of the first. We could fix it by moving the `<aside>` above
the first paragraph but then the DOM would be out of order and it wouldn't read
correctly on mobile.

### Further complications

To make matters worse, we also want to be able to position commentary next to
specific words or phrases. For example:

<Figure>
<Frame src="/examples/sidebar-2/index.html" autoScale={false} />

<p>
A <span ref={r = createRef()}>badly-placed</span> comment that
<span style={{ position: "relative", top: "2px", left: "4px" }}>
doesn't line up
</span>
</p>
</Figure>

<Aside target={r} moveDown={-44}><p>
Yes, red definitely c
<span style={{ color: "#663922" }}>l</span>
<span style={{ color: "#773933" }}>a</span>
<span style={{ color: "#883944" }}>s</span>
<span style={{ color: "#993955" }}>h</span>
<span style={{ color: "#aa3955" }}>e</span>
<span style={{ color: "#bb3955" }}>s</span>.
</p></Aside>

We can use absolute positioning for this but it's not so straightforward. The
paragraph is free-flowing text which means it's hard to predict where the words
will be. It depends on the width of the browser, which font is loaded and its
line height.

We could change the DOM and move the `<aside>` into the text element but again,
that would mean the content's out of order. We'd end up with a horrible jumble:

```html
<p>In this paragraph, I want to comment on
<span>
  <em>these words</em>
  <aside>Does red clash with the theme?</aside>
</span>
which are in the middle of the paragraph.</p>
```

It's also not good practice to do this. React gives us a warning:

> validateDOMNesting(...): `<aside>` cannot appear as a descendant of `<p>`.

The fundamental problem is there's no way in CSS to position elements relative
to arbitrary things. It would be neat if we could do something like this, but
we can't:

<span ref={r = createRef()} />

```css
aside {
  position: element(#thing);
  top: 0;
}
```

<Aside target={r} moveDown={32}>

This hypothetical syntax is based on [this blog
post](https://discourse.wicg.io/t/position-an-element-relatively-to-another-element-from-anywhere-in-the-dom/968)
on the same topic.

</Aside>

I spent a while thinking of other ways to do this in CSS. Flexbox's `order`
property is interesting because it allows for a difference in how the DOM is
structured to how elements are presented. Ultimately, I couldn't find a way and
resorted to <span ref={r = createRef()}>JavaScript</span>.

<Aside target={r}>

Disappointing, I know. If you know of a way, please
[get in touch](https://twitter.com/chrispatuzzo)!

</Aside>

## React

In React, I created an `<Aside>` component that positions itself relative to
a target element. It encapsulates the behavior of figuring our what its
position should be and listens to events that might invalidate that, such as
resizing the window.

Here's a first version:

<span ref={r = createRef()} />
<span ref={r2 = createRef()} />

<Figure>

```javascript
const Aside = ({ target, children }) => {
  const [style, setStyle] = useState(null);

  const align = () => {
    const rectangle = target.current.getBoundingClientRect();
    const offset = window.scrollY + rectangle.top;

    setStyle({ top: offset });
  };

  useEffect(() => {
    align(); // Align when the component is mounted.

    const listener = window.addEventListener("resize", align);
    return () => window.removeEventListener("resize", listener);
  }, []);

  return (
    <aside className={css.aside} style={style}>
      {children}
    </aside>
  );
};

export default Aside;
```

A React component that aligns itself with a target
</Figure>

There are really two main parts to it:

<div className="more_space">

1. The `align` function calculates the y-coordinate of the `target` which is a
[reference](https://reactjs.org/docs/refs-and-the-dom.html) to a DOM
element. It sets the `top` style property to this.
2. The `useEffect` hook aligns the component when it's first mounted and binds
a listener to re-align the component if the browser is resized.

</div>

<Aside target={r} moveDown={140}>

[getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
is [well-supported](https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup)
in modern browsers. It's more reliable than offsetTop and considers CSS transformations.

</Aside>

<Aside target={r2} moveDown={365}>

The function returned from
[`useEffect`](https://reactjs.org/docs/hooks-effect.html) is called when the
component is unmounted. It's used to
[clean up](https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup)
and remove the listener.

</Aside>

The component is used like so:

<span ref={r = createRef()} />
<span ref={r2 = createRef()} />

<Figure>

```jsx
<p>In this paragraph, I want to comment on

<em ref={r=createRef()}>
  these words
</em>

which are in the middle of the paragraph.</p>

<Aside target={r}>
  Does red clash with the theme?
</Aside>
```

How to use the `<Aside>` component
</Figure>

<Aside target={r} moveDown={50}>

I've already `let r` by this point. This is re-assigned to
[`createRef()`](https://reactjs.org/docs/refs-and-the-dom.html#creating-refs)
for each new reference.

</Aside>

<Aside target={r2} moveDown={178}>

`r` is passed as the target.

</Aside>

<!-- fourth-wall-2 -->

### Breaking the fourth wall

As I write this article, I'm using this component a lot.
Let's peek at <span ref={r=createRef()}>the code</span>:

<Aside target={r}>
Well this is unexpected. {/* Waves to self. 👋 */}
</Aside>

<!-- fourth-wall-2 -->

<span ref={r = createRef()} />

<Figure>
<pre><code className="language-jsx">
  {readFile("pages/blog/building-sidebar-react.mdx", "fourth-wall-2")}
</code></pre>

Using the `<Aside>` component in **this** article
</Figure>

<Aside target={r} moveDown={50}>

I'm using a hybrid of Markdown that supports JSX. It's called
[MDX](https://github.com/mdx-js/mdx).

</Aside>

If your browser is wide enough, you _should_ see 'Well this is unexpected' on
the right-hand side of 'the code'. Otherwise, it'll appear in the main flow.

In some cases, there's no word or phrase in the DOM to refer to. For example,
images, videos and code blocks that use the [`<pre>`
tag](https://www.w3schools.com/tags/tag_pre.asp). <span ref={r2 =
createRef()}>For</span> these cases, I built an _escape hatch_ that lets me move
comments down by a fixed amount:

<!-- fourth-wall-3 -->

<span ref={r = createRef()} />

<Aside target={r} moveDown={50}>
For example, this aside is moved down 50 pixels.
</Aside>

<!-- fourth-wall-3 -->

<pre><code className="language-jsx">
  {readFile("pages/blog/building-sidebar-react.mdx", "fourth-wall-3")}
</code></pre>

<Aside target={r2}><p>
These elements tend to have a fixed height, anyway.
</p></Aside>

This amount is then added to the `offset`:

<Figure>

```javascript
const Aside = ({ target, children, moveDown = 0 }) => {
  // ...

  const align = () => {
    // ...
    const offset = window.scrollY + rectangle.top + moveDown;
    setStyle({ top: offset });
  };

  // ...
};
```

Moving comments down by a fixed amount
</Figure>

All told, <span ref={r = createRef()}>this</span> serves very well as a means
of commenting on variety of things: text, images, code and (as we've seen) even
comments themselves!

<Aside target={r}><p>
Even comments about commenting on comments! Ok, I'll stop now.
</p></Aside>

### Incremental improvements

In part two of this article we'll be improving our component in a number of
ways:

- We'll cope with slow-loading images and fonts that break alignment
- We'll handle a race condition that can sometimes happen with `ref`s
- We'll add debouncing, for a smoother browser experience
- We'll extract code into hooks to make things nice and shiny
- We'll stare at pure hatred itself and try to get print layouts working
- We might even break the _fifth wall_

Sounds exciting!? I think so... See you in part two.




<br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>


- high-level component explanation
  - getBoundingClientRect
  - absolute positioning
  - fade in once positioned
  - useEffect to run immediately
- what if content loading is slow?
  - delays hook
  - no ideal, but does the trick
- resize hook
  - dependent on target
  - race condition
  - could disable if below some width but I don't want coupling
- debouncing
  - more efficient, doesn't changes styles constantly
  - didn't write the book, but link to gist
  - still need to call align (not alignSoon) on page load
- printing
  - motivation
    - i don't think anyone will print
    - but i would like to provide offline pdfs - or maybe an ebook someday
    - perhaps use electron-pdf or puppeteer - be nice to use the same pipeline
    - might even help seo
  - by default, won't actually show the sidebar because of pixel width (670?)
  - once it doesn, the alignment is wrong... WHY?
    - link to chrome bug - is this why?
    - therefore, we need to explicitly tell it to re-align on print
    - print events: before, after, media selector
      - browser support?
  - write another hook
  - isn't perfect, but seems to work well enough in webkit
    - of course, more work is needed to make it actually look nice when printed
- quick conclusion
  - hooks make things neat and tidy
  - printing is a mess: seems weird you can't just print what you see
    - there is something in dev tools for this


</Layout>
