import Layout from "../../components/layout";
import Aside from "../../components/aside";
import Figure from "../../components/figure";
import { createRef } from "react";

export let r;

export const navigation = {
  breadcrumbs: [
    { text: "tuzz.tech", href: "/" },
    { text: "blog", href: "/blog" },
  ],
  links: [
    { text: "← Previous" },
    { text: "Next Article →" },
  ]
};

<Layout title="Adding Bash completion to my automation tool" navigation={navigation}>

# Adding Bash completion to my automation tool

<time dateTime="2019-10-05">Published October 5, 2019 by {" "}
<a href="https://twitter.com/chrispatuzzo">Chris Patuzzo</a>
</time>

<Figure.Video src="/videos/zz-completion.mp4">
Bash completion for <a href="https://github.com/tuzz/zz">‘The tuzz automation tool’</a>
</Figure.Video>

Over the years I've developed a command-line tool I use for routine tasks such
as provisioning my machine, generating project templates and managing secrets.
The tool is written in Ruby and I invoke it with the `zz` command.

Most of <span ref={r = createRef()}>what</span> it does is fairly
straightforward and the clever bits are often delegated to something else. For
example, `zz provision` is really just a wrapper that installs and runs Chef
while passing various options to it.

<Aside target={r}>

It uses [chef-solo](https://docs.chef.io/chef_solo.html) which is a slimmed down
version of Chef to run on a single node. No server needed.

</Aside>

Recently, I added Bash completion to my tool. I've wanted this for a while, but
I decided to add it now in preparation
for <span ref={r = createRef()}>secrets management.</span> For example, I want to
be able to type `zz secret --read amaz<TAB><TAB> ` and have it auto-complete to
`zz secret --read amazon/`.  Perhaps hitting `<TAB>` again will list all
secrets under this path, e.g. username, password, access_key, etc.

<Aside target={r}>

I haven't actually implemented secrets management yet. Currently, I'm running
`gpg --encrypt` and `--decrypt` a lot so hopefully I'll find time to add this
soon.

</Aside>

## How Bash completion works

In <span ref={r = createRef()}>Bash</span>, auto-completion is handled through the `complete` ‘built-in’:

```bash
$ type complete
complete is a shell builtin
```

<Aside target={r}>

[Builtins](https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html)
are commands ‘built into’ the shell. They provide basic operations like `echo`,
`help` and `type`:

```bash
$ type type
type is a shell builtin
```

</Aside>

This command allows you to register a method of completion for a command. For
example, an `rgb` command might register its known colors:

```bash
$ complete -W "red green blue yellow purple pink orange" color
```

You could then complete color names:

```bash
$ color <TAB><TAB>
blue    green   orange  pink    purple  red     yellow

$ color p<TAB><TAB>
pink    purple

$ color pi<TAB> # completes to pink
```

The `-W` switch configures a static list of completions that are printed in
alphabetical order. It's just one of many methods to
do <span ref={r = createRef()}>completion.</span>

<Aside target={r}><p>
It's also the simplest.
</p></Aside>

### Registered completions

To list commands with registered completions, run `complete` without arguments:

```bash
$ complete
complete -W 'red green blue yellow purple pink orange' color
complete -F _nodenv nodenv
complete -F _rbenv rbenv
```

Here you can see `nodenv` and `rbenv` support completion. They use the `-F`
switch to specify functions to handle their completion, namely `_nodenv` and
`_rbenv`. It seems to be a convention to prefix these Bash functions with an
underscore.

When you complete one of these commands, their output is context-aware:

```bash
$ rbenv install 2.5<TAB><TAB>
2.5.0          2.5.0-rc1      2.5.1          2.5.2          2.5.3
```

That's helpful! `rbenv` has kindly listed which Ruby 2.5.x versions are available
to install. We could find this out from `rbenv install --list` but that's
innefficient because we'd have to clear our current command then re-type it.

## How completion _functions_ work

When a function is registered as the method of completion with the `-F` switch,
it must comply with an ‘interface’ of sorts. When the function is called, Bash
sets some environment variables that can be used by the completion function.

They <span ref={r = createRef()}>tell</span> it the contents of the
command-line, the cursor position, etc. For example, `$COMP_LINE` contains the
full line that was typed, `$COMP_WORDS` is that same line broken into an array
of words and `$COMP_POINT` is the cursor's index position.

In return, the completion function should set `$COMPREPLY` to specify which
completions to print for the command.

<Aside target={r}>

Using environment variables as a means of passing information back and forth
seems kind of awkward. Bash is pretty old, though.

</Aside>

### An example

Everybody loves FizzBuzz, right? Let's demonstrate Bash completion with a custom
function that *magically* completes the next term in the sequence:

```bash
function _fizzbuzz () {
  length=${#COMP_WORDS[@]}
  number=$((length - 1))

  if   ! ((number % 15)); then COMPREPLY=(fizzbuzz)
  elif ! ((number % 3));  then COMPREPLY=(fizz)
  elif ! ((number % 5));  then COMPREPLY=(buzz)
  else                         COMPREPLY=($number)
  fi
}

complete -F _fizzbuzz fizzbuzz
```

Our <span ref={r = createRef()}>command</span> is called `fizzbuzz` so we name
our completion function `_fizzbuzz`, as is the convention. We first set `length`
to the number of words on the command-line and `number` to one minus this,
since `fizzbuzz` itself counts as a word.

We've probably all seen FizzBuzz before so let's skip the modulo logic. The
important part is to set `$COMPREPLY` - in this case, to an array of the next
term in the sequence.


Now, if we type `fizzbuzz <TAB><TAB>`, Bash completion kicks in and as if by
*magic* the next term in the sequence is appended to the current command-line.
Our `fizzbuzz` command doesn't actually exist but that doesn't seem to matter!

<Aside target={r}>

I do wonder if this could be used as an attack vector:

```bash
function _ls () {
  # do something nasty
}

complete -F _ls ls
```

Of course, we'd need permissions to register completion functions which we won't
have so it's probably fine?

</Aside>

<span ref={r = createRef()} />

<Figure.Video src="/videos/fizzbuzz-completion.mp4">
Using Bash completion to generate the FizzBuzz sequence
</Figure.Video>

<Aside target={r} moveDown="16.5rem">

If the completion function returns a single option, Bash immediately completes
it without prompting us.

That means we can hold down `<TAB>` to continuously complete the FizzBuzz
sequence. Neat!

</Aside>

## The 'zz' completion function

I added Bash completion support in [this
commit](https://github.com/tuzz/zz/commit/c7c90d292a19d2c880c9bac6b50e3d1f0ccfc414).

First, I register a completion function that passes the entire command line
through to another `zz` command. Then `$COMPREPLY` is set to the result of that
command:

```bash
#!/bin/bash

function _zz () {
  COMPREPLY=($(zz complete $COMP_LINE));
};

complete -F _zz zz
```

My philosophy with these things is to ‘get the hell out of `<OBSCURE THING>`’
as soon as possible and handle the result in a more conventional way. In this
case, I want to use my trusty friend _Ruby_ to determine the list of
completions. This may as well be _just another_ `zz` command since I'll need
access to its context.

The <span ref={r = createRef()}>file</span> is written to
`/usr/local/bin/zz-completion.bash` and I source it in my `~/.profile`. I'm
actually using `zz provision` to ensure this file exists and that it’s sourced
in my profile. Now on to the tool-specific behaviour&hellip;

<Aside target={r}><p>
I'm particularly fond of this kind of ‘bootstrapping’ since it pushes the tool
in to the realms of self-reference.
</p></Aside>

## Completing command/option names

My first goal was to implement completion for commands and options. The
idea being, if I type `zz prov<TAB>`, that would complete to `zz provision`
and if I type `zz <TAB><TAB>`, I'd be reminded of all available commands.

The same goes for options. If I type `zz provision --li<TAB>`, I'd like that to
complete to `zz provision --list` and `zz provision --<TAB><TAB>` would
remind me of options for the `provision` command.

This <span ref={r = createRef()}>behaviour</span> is implemented in
[this commit](https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e).

<Aside target={r}><p>
It's probably easier to look at the tests rather than the implementation.
</p></Aside>

It gets complicated and I could have simplified it further but I'm happy it's
tested and can be refactored later. I decided to split the code up by the
‘type’ of completion, i.e. whether it's the name of a command, an option, or
its <span ref={r = createRef()}>arguments</span>.

<Aside target={r}><p>
More on that later.
</p></Aside>

For each type of completion, I defined a method that takes `args` which is the
full command-line typed by the user as an array of words. The method returns an
array of strings which are fed back as the completion options:

```ruby
def complete_command(args)
  commands = filter_commands(args)
  # ...
  commands.map(&:name)
end
```

In this case, `#filter_commands` looks at the command-line argument in the
first position and filters commands that start with that prefix.

<span ref={r = createRef()} />

I made it so these methods can return `false` if this type of completion isn't
relevant. For example, if the user has already typed `provision` (a command), it
doesn't make sense to complete the name of a command since we already have that:

<Aside target={r}>

That means we can or (`||`) all our completion methods together to find the
first one that’s ‘relevant’.

This behaviour is implemented
[here](https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e#diff-c536662908a26a0b8843e81b8ffe42cbR5).

</Aside>


```ruby
def complete_command(args)
  commands = filter_commands(args)

  return false if args.size > 2
  return false if exact_command_match?(commands, args)

  commands.map(&:name)
end
```

The [`#complete_option`](https://github.com/tuzz/zz/commit/046b31d5715661329da8f25eef37de2596a2e59e#diff-c536662908a26a0b8843e81b8ffe42cbR40-R55)
method is more complicated but uses the same idea.

## Completing arguments to options

The final piece of the puzzle is to do contextual completion for options.
My original use-case was to complete `zz secret --read amaz` to `zz secret
--read amazon/`.

Conceptually, it would be nice if `--read` was ‘responsible’ for
determining the list of completions. Perhaps it looks at the file system or
[Hashicorp's Vault](https://www.vaultproject.io/) to decide.

I haven't <span ref={r = createRef()}>implemented</span> the `secret` command
yet, but I can still add support for option completion, for when I do.  [This
commit](https://github.com/tuzz/zz/commit/fddbf52238d3e4ab490750f08148b98a6d20b8d1)
implements `#complete_option_arg` which delegates completion to a Ruby `proc`
set on an option.

<Aside target={r}><p>
The details here don't matter. The key is to make option responsible for
producing its completions.
</p></Aside>

We <span ref={r = createRef()}>can</span> now implement completion for options
by providing a block when they are created. For example, here's how we do that
for `template --type`:

```ruby
def type_option
  help = "sets the type of template (e.g. ruby)"

  @type_option ||= Option.new("t", "type", 1, help) do |args|
    types.select { |t| t.start_with?(args.last) }
  end
end
```

<Aside target={r}>

At time of writing, valid types are `ruby`, `rust` and `cpp`.

</Aside>

The block receives all command-line arguments and returns an array of completion
strings. In this case, we find all template types that start with the last
argument on the command-line, so if the user types `template --type ru`, it
returns `ruby` and `rust`.

A more complicated example is the `provision --only` option which accepts a list
of Chef recipes. For example, you might say `provision --only vim,ruby`.

<span ref={r = createRef()} />

```ruby
def auto_complete_recipe_list(args)
  *head, prefix = args.last.downcase.split(",")
  list = recipes.select { |r| r.start_with?(prefix || "") }

  return recipes if list == [prefix]

  list.map { |l| (head + [l]).join(",") }
end
```

<Aside target={r} moveDown="3rem">

Implemented in [this commit](https://github.com/tuzz/zz/commit/62dbff256963d8ff0a8e23f54e0b5969fd277ba5).

That mysterious `return` statement is explained below.

</Aside>

### A few ‘gotchas’

Bash sometimes tries to be helpful. For example, if all the available
completions start with the same prefix, Bash replaces the word at the end of
the command-line with that prefix. Usually this is helpful, but it can be
surprising.

For example, if we decided to return `ruby` and `rust` as completions for `zz
provision --only vim,ru`, Bash would immediately replace the last word with
`ru` since that's the common prefix, dropping `vim` from the start of the list.

That's why we have copy the list in each completion:

```bash
$ zz provision --only vim,ru<TAB><TAB>
vim,ruby  vim,rust
```

However, this can get noisy when adding a new recipe to the list:

```bash
$ zz provision --only vim,ruby<TAB><TAB>
vim,ruby,aws   vim,ruby,chrome   vim,ruby,dock   # ...many more
```

Ideally, we want it to just return the names of available recipes without all
the noise but we can't do that because Bash will replace our list by the common
prefix of the recipe names. Oh dear!

### Reducing the noise

Well, actually we can use our knowledge of the above and anticipate Bash's
completion behaviour. If there's no common prefix of recipe names, we can
return a nice clean list that doesn't repeat itself:

```bash
$ zz provision --only vim,ruby<TAB><TAB>
aws   chrome   dock   drive   dropbox   ffmpeg   # ...
```

That's what this lines is for:

```ruby
return recipes if list == [prefix]
```

My implementation's a bit simpler in that it just checks for an exact match
between the prefix and the filtered list of recipes. This has the desired
effect and completing `vim,ruby` or `vim,` now displays the full list of
recipes.

This could be smarter and check this ‘common prefix’ more directly, but it's
already pretty complicated. Here are some unit test for this behaviour:

```ruby
expect(complete.call([""])).to include("git", "ruby", "vim")
expect(complete.call(["ru"])).to eq ["ruby", "rust"]
expect(complete.call(["VI"])).to eq ["vim", "virtualbox"]

expect(complete.call(["x"])).to eq []
expect(complete.call(["ruby"])).to include("git", "ruby", "vim")

# Although this exact-matches, there are other options:
expect(complete.call(["Chrome"])).to eq ["chrome", "chromedriver"]

# ...
```

## Closing remarks

It's been fun to understand the mechanics of feature we often don't think about.
Bash completion adds a friendly touch that can make our command-line tools
easier to use through back-and-forth interactions with the user.

I think we should consider completion features in the context of user
experience, accessibility and interface design. We should strive to build
completion behaviour that helps users navigate our tools and discover its
features.

For those implementing this behaviour, it's helpful to know we can ‘escape’ out
to our favourite programming languages without too much difficulty. This blog
post has been about Bash because that's what I use, but the concepts should be
applicable wherever it's implemented - though the mechanics will be different.

Finally, I'd be interested to hear if you come up with some nvoel way to use
completion. [Tweet at me](https://twitter.com/chrispatuzzo) if you write your
own choose-your-own adventure game with it, or some wacky chess program.

Happy auto-completi`<TAB><TAB>`

</Layout>
