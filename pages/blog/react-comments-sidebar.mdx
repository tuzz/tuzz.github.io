import Head from "next/head";
import ImageMeta from "../../components/image_meta";
import VideoMeta from "../../components/video_meta";
import Layout from "../../components/layout";
import Aside from "../../components/aside";
import Figure from "../../components/figure";
import Frame from "../../components/frame";
import readFile from "../../helpers/read_file";
import { createRef } from "react";

export let r;

export const navigation = {
  breadcrumbs: [
    { text: "tuzz.tech", href: "/" },
    { text: "blog", href: "/blog" },
  ],
  links: [
    { text: "← Previous", href: "/blog/palindromic-superpermutations" },
    { text: "Next Article →" },
  ]
};

export const title = "Building a commentary sidebar in React";
export const path = "/blog/react-comments-sidebar";
export const description = "TODO";

<Head>
  <meta property="og:title" content={title} />
  <meta property="og:url" content={`https://tuzz.tech${path}`} />
  <meta property="og:description" content={description} />
  <meta property="og:type" content="article" />

  <meta name="description" content={description} />
  <meta name="keywords" content="Chris Patuzzo,TODO" />
</Head>

<Layout title={title} navigation={navigation}>

<h1>{title}</h1>

<time dateTime="2019-10-26">Published October 26, 2019 by {" "}
<a href="https://twitter.com/chrispatuzzo">Chris Patuzzo</a>
</time>

Over the past weeks, I've been building this blog and writing articles for it.
I've spent a lot of time thinking about the reader. Who are they? Why are they
here? It's often hard to know how much detail to go into and how much background
knowledge to assume.

On the one hand, people are busy. Attentions are short and time is precious. I'd
do well to keep articles lean, focussed and to the point. But that _misses_ the
point. People are here for enjoyment and just presenting the cold hard facts
isn't going to cut it.

I've settled on an approach I hope will cater to a variety of readers. I keep
the main body of content concise and _on topic_ but enrich it with commentary on
the side. This leaves room for elaboration, tangential remarks and all the
whimsy I can <span ref={r = createRef()}>mustard</span>.

<Aside target={r}><p>
I'm so sorry.
</p></Aside>

However, this commentary hides complexity. When <span ref={r =
createRef()}>viewed</span> on a large-enough screen, it's presented in a
sidebar next to the main content. Ideally, comments sit as close as possible to
the word or phrase they refer to. This helps flow and improves continuity.

<Aside target={r}><p>
When viewed on mobile, comments are presented inside the main content but with
softer styles to show they're supplementary.
</p></Aside>

In this article, I'll explain the mechanics of how this works in my React app.
As you'll see, there's a lot to consider to make a robust, responsive and
semantic <span ref={r = createRef()}>solution</span>.

<Aside target={r}><p>
... that's SEO and print friendly.
</p></Aside>

## Structuring the DOM

Putting React to one side for a moment, let's first consider how to structure
the DOM.  HTML5 has the perfect element for our needs:

>The HTML `<aside>` element represents a portion of a document whose content is
only indirectly related to the document's main content. Asides are frequently
presented as sidebars or call-out boxes.
&nbsp;_– [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside)_

That leaves the question of whether to group all commentary together into <span
ref={r = createRef()}>a</span> single `<aside>` or to have one per comment. I
decided on the latter as I think this is more meaningful. Comments are
independent of each other so the DOM should reflect that.

<Aside target={r}><p>
It's also easier to intersperse comments with content using this approach which
is useful for mobile.
</p></Aside>

Here's how that looks in code:

<Figure>
<pre><code className="language-html">
  {readFile("public/examples/sidebar-1/index.html", "body")}
</code></pre>

Comments interspersed with content
</Figure>

### Laying things out

As you can see above, there's no DOM element for the sidebar. I think of a
sidebar as a way to present `<aside>` elements. It really ought to be a
presentational concern.

There are a number of CSS techniques we could use to create a sidebar. There's
flexbox, floats, relative and absolute positioning. This seemed simplest to
me:

<Figure>
<pre><code className="language-css">
  {readFile("public/examples/sidebar-1/styles.scss", "----")}
</code></pre>

One way of creating a sidebar with <span ref={r = createRef()}>CSS</span>
</Figure>

<Aside target={r}>

  Technically it's [Sass](https://sass-lang.com/) as it uses nested rules.

</Aside>

This works by splitting the container in two. The sidebar comments live in the
space created by the `padding-right` rule. They use absolute positioning which
removes them from the document's flow and `right: 1rem` to place them in the
padded region.

We can left-position the `<aside>` elements within the sidebar by setting their
width. This is calculated as `50% - 2rem` to create the illsusion of
padding - by leaving an equal amount of space on the left and right. Here's how
it looks:

<span ref={r = createRef()} />

<Figure>
<Frame src="/examples/sidebar-1/index.html" autoScale={false} />

Using padding to create a sidebar on the right
</Figure>

<Aside target={r} moveDown={25}><p>
This is a live version of the code running in a frame. You can see a standalone
version <a href="/examples/sidebar-1/index.html" target="_blank">here</a>.
</p></Aside>

This isn't quite right because the comment is placed next to the second
paragraph instead of the first. We could fix it by moving the `<aside>` above
the first paragraph but then the DOM would be out of order and it wouldn't read
correctly on mobile.

### Further complications

To make matters worse, we also want to be able to position commentary next to
specific words or phrases. For example:

<Figure>
<Frame src="/examples/sidebar-2/index.html" autoScale={false} />

<p>
A <span ref={r = createRef()}>badly-placed</span> comment that
<span style={{ position: "relative", top: "2px", left: "4px" }}>
doesn't line up
</span>
</p>
</Figure>

<Aside target={r} moveDown={-44}><p>
Yes it {" "}
<span style={{ color: "#773955" }}>d</span>
<span style={{ color: "#883955" }}>o</span>
<span style={{ color: "#993955" }}>e</span>
<span style={{ color: "#aa3955" }}>s</span>.
</p></Aside>

We can use absolute positioning for this but it's not so straightforward. The
paragraph is free-flowing text which means it's hard to predict where the words
will be. It depends on the width of the browser, which font is loaded and its
line height.

We could change the DOM and move the `<aside>` into the text element but again,
that would mean the content's out of order. We'd end up with a horrible jumble:

```html
<p>In this paragraph, I want to comment on
<span>
  <em>these words</em>
  <aside>Does red clash with the theme?</aside>
</span>
which are in the middle of the paragraph.</p>
```

It's also not good practice to do this. React gives us a warning:

> validateDOMNesting(...): `<aside>` cannot appear as a descendant of `<p>`.

The fundamental problem is there's no way in CSS to position elements relative
to arbitrary things. It would be neat if we could do something like this, but
we can't:

<span ref={r = createRef()} />

```css
aside {
  position: element(#thing);
  top: 0;
}
```

<Aside target={r} moveDown={32}>

This hypothetical syntax is based on [this blog
post](https://discourse.wicg.io/t/position-an-element-relatively-to-another-element-from-anywhere-in-the-dom/968)
on the same topic.

</Aside>

I spent a while thinking of other ways to do this in CSS. Flexbox's `order`
property is interesting because it allows for a difference in how the DOM is
structured to how elements are presented. Ultimately, I couldn't find a way and
resorted to <span ref={r = createRef()}>JavaScript</span>.

<Aside target={r}><p>
Disappointing, I know.
</p></Aside>

## React



<br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>


- high-level component explanation
  - getBoundingClientRect
  - absolute positioning
  - fade in once positioned
  - useEffect to run immediately
- what if content loading is slow?
  - delays hook
  - no ideal, but does the trick
- resize hook
  - dependent on target
  - race condition
  - could disable if below some width but I don't want coupling
- debouncing
  - more efficient, doesn't changes styles constantly
  - didn't write the book, but link to gist
  - still need to call align (not alignSoon) on page load
- printing
  - motivation
    - i don't think anyone will print
    - but i would like to provide offline pdfs - or maybe an ebook someday
    - perhaps use electron-pdf or puppeteer - be nice to use the same pipeline
    - might even help seo
  - by default, won't actually show the sidebar because of pixel width (670?)
  - once it doesn, the alignment is wrong... WHY?
    - link to chrome bug - is this why?
    - therefore, we need to explicitly tell it to re-align on print
    - print events: before, after, media selector
      - browser support?
  - write another hook
  - isn't perfect, but seems to work well enough in webkit
    - of course, more work is needed to make it actually look nice when printed
- quick conclusion
  - hooks make things neat and tidy
  - printing is a mess: seems weird you can't just print what you see
    - there is something in dev tools for this


</Layout>
