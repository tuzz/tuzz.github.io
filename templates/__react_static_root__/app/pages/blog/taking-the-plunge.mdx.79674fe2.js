(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{159:function(e,t,n){"use strict";var i=n(6),a=n.n(i),o=n(24),r=n.n(o),s=n(7),l=n.n(s),h=n(160),d=n.n(h),c=function(e){var t=e.children,n=e.href,i=e.className,a=l()(t,2),o=a[0],r=a[1],s=n?React.createElement("a",{href:n,target:"_blank"},o):o;return React.createElement("figure",{className:"".concat(i," ").concat(d.a.figure)},s,React.createElement("figcaption",null,React.createElement("span",{className:d.a.arrow},"▲"),React.createElement("span",null,r)))};c.Video=function(e){var t=e.children,n=e.href,i=e.src,o=r()(e,["children","href","src"]);return React.createElement(c,a()({href:n||i},o),React.createElement("video",{muted:!0,autoPlay:!0,playsInline:!0,loop:!0},React.createElement("source",{src:i,type:"video/mp4"})),t)},c.Image=function(e){var t=e.children,n=e.href,i=e.src,o=e.alt,s=r()(e,["children","href","src","alt"]);return React.createElement(c,a()({href:n||i},s),React.createElement("img",{src:i,alt:o}),t)},t.a=c},160:function(e,t,n){e.exports={figure:"styles-figure_23Vi",arrow:"styles-arrow_2C7-"}},77:function(e,t,n){"use strict";n.r(t),n.d(t,"r",(function(){return i})),n.d(t,"title",(function(){return g})),n.d(t,"path",(function(){return y})),n.d(t,"type",(function(){return f})),n.d(t,"description",(function(){return w})),n.d(t,"keywords",(function(){return I})),n.d(t,"image",(function(){return v})),n.d(t,"video",(function(){return j})),n.d(t,"date",(function(){return O})),n.d(t,"default",(function(){return _}));var i,a=n(6),o=n.n(a),r=n(24),s=n.n(r),l=(n(0),n(25)),h=n(161),d=n(162),c=n(163),u=n(67),p=n(164),m=n(165),b=n(159),g="GameDev Notes 1: Taking the Plunge",y="/blog/taking-the-plunge",f="article",w="How I added swimming to my indie platform game.",I="Chris Patuzzo,game development,Rust,programming,swimming,water,underwater,animation",v={path:"/images/gamedev-1/cloak-fin.gif",width:300,height:300,bytes:1021461,type:"image/gif"},j={path:"/videos/cloak-fin.mp4",width:600,height:600,bytes:254449,type:"video/mp4"},O="2020-10-02T12:00Z",k={r:i,title:g};function _(e){var t=e.components,n=s()(e,["components"]);return Object(l.b)("wrapper",o()({},k,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)(c.a,o()({title:g,path:y,type:f,description:w,keywords:I,image:v,video:j},{mdxType:"MetaTags"})),Object(l.b)(u.a,{previous:h.pairProgrammingInSentient,mdxType:"NavBar"}),Object(l.b)("title",null,g),Object(l.b)("h1",null,"GameDev Notes 1:",Object(l.b)("br",null),"Taking the Plunge"),Object(l.b)("time",{dateTime:O},"Published ",Object(d.a)(O)," by "," ",Object(l.b)("a",{href:"https://twitter.com/chrispatuzzo"},"Chris Patuzzo"),Object(l.b)(p.a,{mdxType:"FeedIcon"})),Object(l.b)("div",{className:"note"},Object(l.b)("p",null,"Follow me on ",Object(l.b)("a",o()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo"}),"twitter")," to hear how you can be\na playtester when the time comes.")),Object(l.b)("p",null,"For the past few months I’ve been writing my first ever indie game (in Rust).\nIt’s a 2D ",Object(l.b)("span",{ref:i=createRef()},"puzzle-platformer")," that I’m super\nhappy with so far. I think it’s pretty unique and I’m excited to see where it\ngoes. I’m quite stubborn and like things done a particular way so I’m not using\nan off-the-shelf engine like Unity and I’m writing almost everything myself\nexcept for some of the low-level libraries. It’s challenging and fun."),Object(l.b)(m.a,{target:i,mdxType:"Aside"},Object(l.b)("p",null,"I haven’t named my game yet.")),Object(l.b)("p",null,"Anyway, some friends suggested I share what I’ve been doing. Until now, I’ve\nbeen reluctant to because I already have heaps to do but I think it would be a\nshame if this knowledge is lost (because I’ll inevitably forget). Therefore,\nI’m going to try and write occasional gamedev notes and publish them here. I\ndon’t guarantee they’ll all make sense without extra context. I’m hoping to\nrefer back to them later, e.g. if I turn them into YouTube videos or something."),Object(l.b)("p",null,"Most recently (the last few days) I’ve been working on adding water and\nswimming to the game. Currently the player character is land-based and I wanted\nto expand that out to add variety and a new set of constraints for the player\nto grapple with. There are story reasons as well, but I won’t spoil it. Before\ndiving(!) in, here’s a quick demo of what I made this week:"),Object(l.b)(b.a.Video,{src:"/videos/swimming-low-res.mp4",href:"/videos/swimming-high-res.mp4",alt:"Demo of swimming"},"Demo of swimming in my game (click for a higher resolution)"),Object(l.b)("p",null,"It probably doesn’t look much compared to AAA games but I added a few niceties\nto make it visually interesting and fun to navigate. The first thing I worked\non was a new component called ",Object(l.b)("inlineCode",{parentName:"p"},"Liquid")," that I can attach to a game entity. I\ndecided to use the more general term ‘liquid’ rather than ‘water’ because I\nalready use the term ‘solid’ and it seemed to fit better with the language of\nmy engine."),Object(l.b)("h2",null,"Liquids"),Object(l.b)("p",null,"Here are the properties I can currently set on a liquid:"),Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-rust"}),"Liquid {\n    direction_of_flow: Vector2f::new(0.2, 0.),\n    default_buoyancy: Buoyancy {\n      upthrust: 1.0,\n      drag_coefficients: (0.15, 3.),\n      jump_scale_factor: 0.4,\n      waterline: 0.3,\n      settle_rate: 0.01,\n    },\n}\n")),Object(l.b)("p",null,"Before I can do anything interesting with these properties, I first need to\nknow which entities are ‘submerged’ in the liquid. I created a resource called\n",Object(l.b)("inlineCode",{parentName:"p"},"SubmergedEntities")," that tracks this and a system that incrementally keeps this\nresource up to date based on which entities have moved since the last update. I\nconsider an entity ‘submerged’ if its bounding box overlaps with the liquid,\neven slightly. In other parts of the code I need to distinguish ‘partially’\nversus ‘fully’ submerged, but I check this as needed."),Object(l.b)("p",null,"With that out of the way, I wrote a ",Object(l.b)("inlineCode",{parentName:"p"},"LiquidPhysics")," system that applies these\nproperties to submerged entities. I made it so this only applies to those that\nhave a ",Object(l.b)("inlineCode",{parentName:"p"},"Mass")," component so that static geometry (e.g. the floor) isn’t\naffected. I initially tried to make ",Object(l.b)("inlineCode",{parentName:"p"},"LiquidPhysics")," work in harmony with my\nexisting ",Object(l.b)("inlineCode",{parentName:"p"},"GravityPhysics")," system but that turned out to be really fiddly so I\nabandoned that. Instead, it’s one or the other: if an entity is submerged,\n",Object(l.b)("inlineCode",{parentName:"p"},"LiquidPhysics")," handles it. If it is not, ",Object(l.b)("inlineCode",{parentName:"p"},"GravityPhysics")," does."),Object(l.b)("p",null,"Here’s a quick summary of what each properties does:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"direction_of_flow:")," controls the direction/speed entities move in the liquid"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"upthrust:")," the same as above but only for the y-direction"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"drag_coefficients:")," controls how rapidly an entity reaches the flow velocity when it’s not moving at that velocity, e.g. if the player jumps into some water, they will initially be travelling much faster than it"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"jump_scale_factor:")," when an entity is ‘walking underwater’, i.e. it is standing on the ground in liquid, this parameter reduces the velocity applied when it jumps"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"waterline:")," when an entity is floating at the top of the liquid, this parameter controls how high it naturally sits above the liquid, as a fraction of height"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"settle rate:")," when an entity isn’t sitting at its waterline, this parameter controls how quickly it converges to it")),Object(l.b)("p",null,"There’s quite a lot going on here but ",Object(l.b)("inlineCode",{parentName:"p"},"LiquidPhysics")," didn’t turn out too\ncomplicated, only 100 lines or so. I did a bunch of reading about ",Object(l.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Terminal_velocity"}),"terminal\nvelocity")," and\n",Object(l.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Drag_(physics)"}),"drag")," before writing it which\nhelped. The reason most of the properties are nested in a ",Object(l.b)("inlineCode",{parentName:"p"},"default_buoyancy"),"\nfield is so I can override them on a per-entity basis. For example, I might\nwant something to float on the surface while everything else sinks or to set a\nlower waterline for a pirate ship."),Object(l.b)("h2",null,"Swimming"),Object(l.b)("p",null,"I probably spent most of my time working on the swimming controls. I watched a\nfew videos of how swimming is typically handled in 2D games. In ",Object(l.b)("a",o()({parentName:"p"},{href:"https://youtu.be/1wR8x5b_ExM?t=298"}),"Super\nMario"),", the swimming is a bit like jumping.\nThe player constantly sinks and swims up by jumping. They stay upright at all\ntimes. I eventually got a nostalgia trip watching how swimming works in ",Object(l.b)("a",o()({parentName:"p"},{href:"https://youtu.be/lSbLrWRLWl4?t=51"}),"Ecco\nthe Dolphin"),". I never really understood what\nto do in that game but I remember it being fun to play. I like that the\ncharacter rotates to face the direction they’re heading. The boost is fun, too."),Object(l.b)("p",null,"Currently, the on-land controls of my game are very responsive - you can\nimmediately switch directions. I figured it would be a nice change to introduce\nsome delay in water so you first have to turn to face the direction you want to\ngo, perhaps bumping into a wall along the way. You effectively always move in\nthe direction your head is pointing and turn at some arbitrary rate I can\ncontrol. Most people are better on land than in water so this fits well with\nreality. Another minor reason for choosing this was that my engine works with\narbitrary transforms - it’s richer than a tile-based engine, which many 2D\ngames are built on, so I figured I may as well make use of this capability. If\nI add analogue controller support, I can see it working well with that, too."),Object(l.b)("span",{ref:i=createRef()}),Object(l.b)("p",null,"The way this works is by mapping the direction you’re pressing to one of the\neight intercardinal directions. I use the nautical term\n‘",Object(l.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Course_(navigation)"}),"course"),"’ for this. I then\nget the angle the player is current facing which I call its\n‘",Object(l.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Heading_(navigation)"}),"heading"),"’ and figure out\nwhich direction to turn to get there soonest. This is a bit fiddly because\nangles wrap around and are usually in the range -PI to PI (from the\n",Object(l.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Atan2"}),Object(l.b)("inlineCode",{parentName:"a"},"atan2"))," function). Rust has a\n",Object(l.b)("a",o()({parentName:"p"},{href:"https://doc.rust-lang.org/std/primitive.f32.html#method.rem_euclid"}),Object(l.b)("inlineCode",{parentName:"a"},"rem_euclid")),"\nfunction that helps with this. In the case when the player switches to the\nopposite direction (e.g. left to right), either direction works. I decided to\narbitrarily* turn counter-clockwise."),Object(l.b)(m.a,{target:i,mdxType:"Aside"},Object(l.b)("p",null,"My very weak argument for turning counter-clockwise is that historically,\nlevels go from left to right so it seems likely you’d reach some goal at the\nend of the level on the right. If you then want to return to ‘return home’,\nyou’d probably prefer to head up towards the surface, rather than down farther\ninto the water.")),Object(l.b)("p",null,"Some things I added later were ‘hold space to boost’ (inspired by Ecco) and\nautomatic uprighting. If the player is idle, it seemed a bit weird to just\nleave them hanging upside down in water so after a couple of seconds, I rotate\nthem back to their upright position. I quite liked the possibility of using\nthis for some tricky puzzle later in the game. Maybe there’s a spike-ridden\nsection that requires very fine turns and requires you to rotate back to your\nupright position, rather than holding up and turning in a wider arc. That’s\npretty contrived, though."),Object(l.b)("p",null,"One thing that caused me a headache was what to do at the surface of the water.\nWhat was basically happening was the player was swimming past the waterline and\nout of the liquid. They were then falling back down again when ",Object(l.b)("inlineCode",{parentName:"p"},"GravityPhysics"),"\nkicked in, flipping between the two. It was very glitchy. My solution to this\nwas to introduce some logic for\n‘",Object(l.b)("a",o()({parentName:"p"},{href:"https://ell.stackexchange.com/questions/95478/bobbing-in-the-water"}),"bobbing"),"’\non the water. I tried a few variations but eventually settled on a simple\napproach that allowed the player to keep swimming up for a small amount of time\nabove their waterline but at a greatly reduced speed. After which, they’d drop\ndown (at the same speed) until below the waterline where they could ‘bob up’\nagain."),Object(l.b)("p",null,"To control the swim speed and rate they turn in water, I added ",Object(l.b)("inlineCode",{parentName:"p"},"swim_speed")," and\n",Object(l.b)("inlineCode",{parentName:"p"},"turn_rate")," to my pre-existing ",Object(l.b)("inlineCode",{parentName:"p"},"Agility")," component that controls things like\nthe player’s foot speed and width of their jump arc."),Object(l.b)("h2",null,"Walking underwater"),Object(l.b)("p",null,"I decided I wanted the player to be able to walk at the bottom of the liquid.\nThat’s kind of how it works in reality and it didn’t ",Object(l.b)("em",{parentName:"p"},"seem")," like it would be\nhard to add. I basically distinguish between being ‘suspended’ in the liquid\nand not (e.g. when walking at the bottom). When you’re not suspended, the\nplayer controls fall through to the already existing walking/jumping controls\nbut with a few changes, mostly just slowing the player down and reducing their\njump velocity (using the ",Object(l.b)("inlineCode",{parentName:"p"},"jump_scale_factor")," I mentioned earlier). You also\ncan’t boost to go faster."),Object(l.b)("p",null,"The slight difficulty here is that normally, gravity is pushing down on you,\nwhich keeps you on the ground. If you swim down to the ground but then stop\npressing down, it doesn’t know you’re still ‘touching’ the ground because\nthere’s nothing pushing you into it each update (unless the liquid has negative\nflow in the y-direction). Maybe this isn’t a problem for better engines than\nmine, but my fix was to basically constantly apply a negative velocity of the\nplayer’s swim speed to keep them anchored on the ground after reaching it. I\nlike this solution because it means if the liquid has a lot of upthrust - more\nthan the player’s swim speed - they won’t be able to ‘cheat’ and stick to the\nground when they shouldn’t be able to. Similarly, my solution for bobbing on\nthe water has a similar property. Once you’re pushed under the water, its flow\ntakes over and out-paces your swim speed."),Object(l.b)("p",null,"A problem I ran into at this point was with accidentally killing the player.\nWhen walking on the ground, i first reset the player’s rotation so they’re\nupright, but if they’re too close to the ground (swimming parallel to it), this\ncan sometimes place the player entity inside the ground. I have some code that\ntries to detect if the player has been crushed based on the magnitude of\ncollision response. This can sometimes trip and kill the player. Not good!"),Object(l.b)("p",null,"My solution (read: hack) for this is to give the player a ‘free pass’ from the\ngrim reaper for a single frame - the exact moment their rotation is reset. I\nalso re-position the player slightly to reduce the size of this collision and\nhopefully prevent any obscure/unlikely out-of-bounds problems this behaviour\ncould cause. From testing, this seems to work fine, although there are still\nsome weird things around locking on to ladders I need to look into when I have\nsome debugging energy."),Object(l.b)("p",null,"Speaking of ladders, you can climb ladders underwater, too! Again, I made the\ncontrols fall through to the existing code (the ",Object(l.b)("inlineCode",{parentName:"p"},"LadderControl")," system) when it\ndetects you’re trying to climb. The only real difference is I don’t allow the\nplayer to jump up from a ladder at all. They just ‘drop’ and go back to\nswimming which seemed most natural."),Object(l.b)("p",null,'Speaking of doors (oh, no one mentioned doors?), you can go through doors\nunderwater, too! Again, I made the controls " " " " " " ... you get the\nidea. One thing to be slightly careful of is the ‘up’ key is now overloaded in\nthat the player uses it to ',Object(l.b)("span",{ref:i=createRef()},"swim")," up and to go\nthrough doors. Underwater, it only activates the door if the ‘up’ key is\npressed and released again within half a second."),Object(l.b)(m.a,{target:i,mdxType:"Aside"},Object(l.b)("p",null,"This was slightly\ninspired by Vim’s leader key timeout. Whether it’ll feel ok in practice remains\nto be seen.")),Object(l.b)("p",null,"Fortunately, all of the above Just Works with another feature I have in the\nengine: ",Object(l.b)("strong",{parentName:"p"},"moving platforms"),". This glues entities to platforms if they’re\n‘grounded’ on them. They inherit the velocity of the platform, which gives the\nillusion they’re being moved by it. I’m glad this still works underwater\nbecause I could see this being useful to move the player through water more\nquickly than they can swim. One minor difference underwater is that I made the\nplayer lose their momentum as soon as they leave the platform which seems more\nrealistic due to the increased drag of the water. On land, the player preserves\nthis momentum since the drag from air is negligible almost all the time (unless\nyou’re moving really quickly)."),Object(l.b)("p",null,"Finally, a slightly weird thing, as far as visuals are concerned is that the\nplayer immediately flips to their upright position as soon as they touch the\nground. This looks strange if you’re swimming directly down and then are\nflipped upright in the blink of an eye, but I won’t lose sleep over it."),Object(l.b)("h2",null,"Animation"),Object(l.b)("p",null,"I’m ",Object(l.b)("a",o()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo/status/1276154571027550209"}),"trying to\ndraw")," the game\nassets myself. It takes me forever but I basically use Procreate (like a\ncomplete beginner) on my iPad Pro to draw individual sprites and then schedule\nthem using a ",Object(l.b)("inlineCode",{parentName:"p"},"SpriteAnimation")," component in my engine. Here’s how I set up the\ntimings for the ",Object(l.b)("inlineCode",{parentName:"p"},"SWIM_RIGHT")," animation:"),Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-rust"}),"Sequence::looping(vec![\n    (0.15, SWIM_RIGHT_1), (0.25, SWIM_RIGHT_2), (0.15, SWIM_RIGHT_3),\n    (0.1, SWIM_RIGHT_4), (0.15, SWIM_RIGHT_5), (0.4, SWIM_RIGHT_6),\n    (0.1, SWIM_RIGHT_7), (0.1, SWIM_RIGHT_8),\n])\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"SWIM_RIGHT_6")," frame is the one where the player character has his arms by\nhis side after performing a stroke of swimming. It’s supposed to look like\nthey’re gliding through the water for a brief moment before taking another\nstroke. My drawing skills are not very good though. I really struggled to find\ngood side-on examples of people doing breast stroke (which I arbitrary decided\non). I found some ",Object(l.b)("a",o()({parentName:"p"},{href:"https://www.youtube.com/watch?v=9K1hcdvTLAk"}),"reference\nvideos")," on YouTube that helped a\nlot."),Object(l.b)("p",null,"My treading water animation is even worse and I ",Object(l.b)("em",{parentName:"p"},"might")," replace it later, or\njust get rid of it entirely but it’ll do for now. It kicks in when the player\nis fully upright and not pressing a directional key in the water. It was\nsupposed to look like they were lifting their feet back a bit and leaning down\ninto the water, but it just looks like their legs are contorting awkwardly. Oh\nwell!"),Object(l.b)(b.a.Image,{src:"/images/gamedev-1/contorted-legs.png",alt:"Contorted legs"},"Cortorted legs: I'm not very good at drawing!"),Object(l.b)("p",null,"After setting up an animation (like the one above), I have to schedule it to\nplay at the right time (and speed) based on what the player is doing. The logic\nfor this gets really hairy as you sometimes need to transition between\nanimations based on time delays, which animation was playing previously, which\ndirection the player was most recently facing, etc. My very painful way of\nhandling this is a giant ",Object(l.b)("inlineCode",{parentName:"p"},"match")," statement that is a kind of state machine."),Object(l.b)("p",null,"I originally wanted the player to fall into the water using their normal\nfalling animation before switching to the swimming animations after pressing a\ndirectional key but I spent several frustrated hours trying to get this to work\nproperly. I eventually gave up and did a much simpler thing. Here are the lines\nI added to my ",Object(l.b)("inlineCode",{parentName:"p"},"match")," statement, which barely even use the conditions of the\nmatch statement besides being ",Object(l.b)("inlineCode",{parentName:"p"},"suspended")," (in liquid):"),Object(l.b)(b.a,{mdxType:"Figure"},Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-rust"}),"let (state, speed) = match (climbing, grounded, suspended, x_dir, y_dir, previous, *previous_x, time) {\n    (_, _, true, _, _, _, _, _) if swimming == UP    => (SWIM_UP, 0.),\n    (_, _, true, _, _, _, _, _) if swimming == DOWN  => (SWIM_DOWN, 0.),\n    (_, _, true, _, _, _, _, _) if swimming == LEFT  => (SWIM_LEFT, swim_speed * SWIM_SPEED),\n    (_, _, true, _, _, _, _, _) if swimming == RIGHT => (SWIM_RIGHT, swim_speed * SWIM_SPEED),\n\n    (_, _, true, _, _, _, _, _) if facing == UP    => (TREAD_WATER, TREAD_SPEED),\n    (_, _, true, _, _, _, _, _) if facing == DOWN  => (SWIM_DOWN, 0.),\n    (_, _, true, _, _, _, _, _) if facing == LEFT  => (UPRIGHT_LEFT, 1.),\n    (_, _, true, _, _, _, _, _) if facing == RIGHT => (UPRIGHT_RIGHT, 1.),\n\n    // ... 50 much more horrible and order-dependent lines\n};\n")),Object(l.b)("p",null,"Scheduling the swimming animations to play at the right time")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"SWIM_DOWN"),", ",Object(l.b)("inlineCode",{parentName:"p"},"UPRIGHT_LEFT")," and ",Object(l.b)("inlineCode",{parentName:"p"},"UPRIGHT_RIGHT")," animations are just static\nframes with the player facing in each of those directions. I tried and failed\nfor two or three hours to draw animations for swim up/down with the player\nfacing the camera. Eventually I gave and up decided to solve the problem the\nway I know best, by layering on some programming to make the behaviour look\n‘intentional’ rather than due to my hopelessness at drawing (see ‘Visual\ndelights’ below)."),Object(l.b)("p",null,"I decided to make the player face the camera when swimming up and have their\nback to the player when swimming down. I partly did this for variety, but this\nfeels intuitively right to me for some reason and I don’t know why. Maybe\nbecause when you’re swimming down, there’s less light so you can’t really see\nwhere you’re going. I don’t know. What weird thing is going on in that head of\nmine?"),Object(l.b)("h2",null,"Sprite scaling"),Object(l.b)("p",null,"Fun fact: the character in the swimming sprites is actually slightly smaller\nthan the rest of the sprites (e.g. when walking). This is because I needed to\nscale it down to fit the extended arms and legs in. This really messed me up\nand made the animation process more infuriating. I really didn’t want to change\nthe player’s transform size depending on which animation frame they were on, so\nI implemented something I’ve wanted/needed in my engine for a while which is\n‘sprite scaling’."),Object(l.b)("p",null,"This basically allows you to scale the sprite of an entity to be larger (or\nsmaller) than its collider so that it can be displayed at one size, but it’s\ntreated in the engine at a different size - at least for the purpose of\ncollision detection / resolution, etc. I don’t know why I didn’t add this\nsooner as it was really easy to add (10 minutes). It just never seemed high\nenough priority, I guess."),Object(l.b)("p",null,"The reason I’ve wanted this for a while is so I can stop the player hovering in\nthe air so much when they inch off a platform. There’s additional horizontal\nspace in the walking animation sprites that’s wider than the player’s feet. If\nthe collider is sized to the full width of the largest sprite, it means the\nplayer can effectively stand on thin air when there’s the tiniest overlap at\nthe edge that meets the platform. With the updated size, you still can but to a\nlesser extent than before:"),Object(l.b)(b.a.Image,{src:"/images/gamedev-1/thin-air.png",alt:"Standing on thin air"},"Standing on thin air, the collision box is shown in red"),Object(l.b)("p",null,"After adding sprite scaling, I decided to take a bit of time out to size the\non-land sprites correctly first. I guess I just needed a break from the\nswimming stuff for a few hours. This was a bit fiddly because many of the\ntriggers (e.g. when to move the camera) are activated when the player’s\ncollision box bumps into them. With that being slightly smaller, they ALL\nneeded to be moved by a smidgen. Mindless work but my frazzled brain didn’t\nmind. I also made some of the puzzles easier by widening some platforms that\nwere a bit hard to land on with the reduced collider size. Here’s an example:"),Object(l.b)(b.a.Image,{src:"/images/gamedev-1/level-before.png",alt:"Narrow platforms"},"Narrow platforms: harder to land on with a smaller collision box"),Object(l.b)(b.a.Image,{src:"/images/gamedev-1/level-after.png",alt:"Wider platforms"},"Wider platforms: easier to land on with a smaller collision box"),Object(l.b)("p",null,"With sprite scaling in place, I could scale the swimming sprites up (a whopping\n8%). You can see this slight scaling at the edges of the water where the\nplayer’s head overlaps the wall a bit:"),Object(l.b)("h2",null,"Visual delights"),Object(l.b)("p",null,'With all the functional stuff out of the way, I decided to try and make things\npretty. The first thing I wanted to do something about were the static\nanimations I was using for swimming up and down. These are static frames where\nthe player is facing or has his back to the camera. Kind of naff. My\ningenious/ridiculous plan was to use the black smoke-y creature as a kind\nof fin to make it look like it was propelling the player up or down. This is\nthe kind of thing I mean when I put "creative problem solver" on my CV.'),Object(l.b)(b.a.Video,{src:"/videos/cloak-fin.mp4",alt:"Creative problem solving"},"Creative problem solving: using the ‘cloak’ as a kind of fin"),Object(l.b)("p",null,"This was actually quite easy to implement. My particle system already supports\nmany of the features I need to emit particles relative to some rotated\ndirection (that oscillates back and forth). I made it so the ‘cloak’ is\nattached to the player’s feet when swimming up or down and the rate of\noscillation and range of angles change when boosting (may as well add this). It\nlooks a bit goofy but it’s unique and I like it. It subtly reinforces the\nnotion this creature is there to help you, which may or may not be true. WHO\nKNOWS!?"),Object(l.b)("p",null,"While I worked on that part of the code, I made a few changes that meant the\nplayer wouldn’t have to wait around so much in other parts of the game.\nPreviously, the cloak’s behaviour was, for all intents and purposes, completely\nrandom. Now it will do something potentially helpful with a configurable\nprobability. I can use this to tune the pace of the game for some of the\npuzzles which might frustrate the player if they have to wait around too long.\nSorry I’m being so vague about all this, I don’t want to give ",Object(l.b)("em",{parentName:"p"},"all")," my secrets\naway."),Object(l.b)("span",{ref:i=createRef()}),Object(l.b)("p",null,"For the player, I added two emitters while swimming: ",Object(l.b)("inlineCode",{parentName:"p"},"AIR_BUBBLES")," and\n",Object(l.b)("inlineCode",{parentName:"p"},"PROPULSION_BUBBLES"),". The former is active all the time while the player is\nsubmerged, whereas the latter activates while the player is submerged AND\npressing a directional key. My particle system is getting pretty fancy/mature\nat this point which made adding emitters really easy. They’re basically just a\nbig bag of magic numbers. Here’s how ",Object(l.b)("inlineCode",{parentName:"p"},"AIR_BUBBLES")," is set up:"),Object(l.b)(b.a,{mdxType:"Figure"},Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-rust"}),"Emitter {\n    enabled: true,\n    spawn_rate: 2.0.into(),                       // On average, emit two particles per second using a Poisson distribution.\n    texture: (BUBBLE as f32).into(),\n    color_map: (&[STANDARD] as &[usize]).into(),\n    opacity: (0.5..1.0).into(),                   // Randomly choose an opacity between 0.5 and 1.0.\n    duration: (1.0..2.0).into(),\n    scale: (0.05..0.07).into(),                   // Randomly choose a uniform size.\n    rotation: (0.0..2. * PI).into(),\n    position: (-0.1..0.1, 0.75..0.95).into(),     // Position the bubbles approximately where the player's face is.\n    velocity: (-1.0..1.0, 0.5..1.5).into(),       // Bubbles should generally travel upwards.\n    fade_time: (0.).into(),                       // Don't fade out bubbles, make them pop.\n    z_index: 1.0.into(),                          // Place bubbles in front the entity they're attached to (the player).\n    lit: 1.0.into(),                              // These particles are subject to lighting.\n    relative: Relative {\n        velocity_rotation: false,                 // Bubbles should always travel upwards, regardless of player rotation.\n        ..Relative::default()                     // (many other settings are hidden in here)\n    }\n}\n")),Object(l.b)("p",null,"The particle emitter that produces air bubbles")),Object(l.b)(m.a,{target:i,mdxType:"Aside"},Object(l.b)("p",null,"I switch off the emitters as the player reaches the surface as I didn’t want\nbubbles to travel above the liquid. This was fairly easy to introspect based on\nthe parameters of the emitter and the bounding boxes of the player and liquid.")),Object(l.b)("p",null,"Finally, I added one more emitter: this time to the liquid. Currently, I just\nrender a pure blue sprite in front of the player with some a small opacity (0.3\nor so). I wanted to try and convey the  (combined) ",Object(l.b)("inlineCode",{parentName:"p"},"direction_of_flow")," and\n",Object(l.b)("inlineCode",{parentName:"p"},"upthrust")," of the liquid to the player. I basically render some blurry black\nand white particles that travel in the direction of flow (thin end first). It\ntook me some experimenting to settle on this approach. I first tried some\ntextured water sprites, but the particle approach looks pretty good I think and\nis built from stuff I already have which I like."),Object(l.b)("p",null,"If the liquid doesn’t have flow, I just randomly rotate the particles instead.\nI reduce the opacity a bit to place less emphasis on the liquid’s\n(non-existent) flow since I guess I want the player to not be subconsciously\nconfused by it. Here’s that emitter:"),Object(l.b)(b.a,{mdxType:"Figure"},Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-rust"}),"Emitter {\n    enabled: true,\n    spawn_rate: (scale.x * scale.y * 10.).into(),             // The number of particles is proportional to the liquid's area.\n    texture: (&[WHITE_BLUR, BLACK_BLUR] as &[usize]).into(),  // Add highlights and lowlights.\n    color_map: (&[STANDARD] as &[usize]).into(),\n    opacity: opacity,\n    duration: (1.0..5.0).into(),\n    scale: (0.2..1.0, 0.1..0.5).into(),                       // Randomly choose a non-uniform size (there are two ranges).\n    rotation: angle.into(),\n    position: (-scale.x..scale.x, -scale.y..scale.y).into(),  // Particles emit uniformly from the entire region of the liquid.\n    velocity: (x_vel, y_vel).into(),                          // Match the flow of the water.\n    fade_time: (0.5..1.0).into(),\n    z_index: (-3.0..0.0).into(),                              // Place some particles in front and some behind submerged entities.\n    lit: (1.0).into(),\n    relative: Relative::default(),\n}.into()\n")),Object(l.b)("p",null,"Emitting particles in the direction of the liquid’s flow")),Object(l.b)(b.a.Image,{src:"/images/gamedev-1/liquid-flow.png",alt:"Swimming against flow"},"A strong current with a particles extended in the direction of flow"),Object(l.b)("h2",null,"Summary"),Object(l.b)("p",null,"In summary, it turned out to be a surprising amount of work to add water and\nswimming to my engine/game, but I’m fairly happy with the result. There’s\nplenty that could be improved (e.g. hire an actual artist) but I probably\nover-engineered things to a greater extent than I’ll ever need for most\nscenarios. It took almost a full week of long days to figure all this out and\nget it working the way I wanted."),Object(l.b)("p",null,"Hopefully you got something out of this. I’ll announce more of these on\n",Object(l.b)("a",o()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo"}),"twitter")," so please follow me there.\nEventually I’ll open things up to playtesters so let me know there if that\nappeals to you. Stay safe."),Object(l.b)(u.a,{previous:h.pairProgrammingInSentient,mdxType:"NavBar"}))}_.isMDXComponent=!0}}]);