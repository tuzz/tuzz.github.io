(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{159:function(e,t,n){"use strict";var a=n(6),o=n.n(a),r=n(24),i=n.n(r),s=n(7),c=n.n(s),l=n(160),b=n.n(l),p=function(e){var t=e.children,n=e.href,a=e.className,o=c()(t,2),r=o[0],i=o[1],s=n?React.createElement("a",{href:n,target:"_blank"},r):r;return React.createElement("figure",{className:"".concat(a," ").concat(b.a.figure)},s,React.createElement("figcaption",null,React.createElement("span",{className:b.a.arrow},"▲"),React.createElement("span",null,i)))};p.Video=function(e){var t=e.children,n=e.href,a=e.src,r=i()(e,["children","href","src"]);return React.createElement(p,o()({href:n||a},r),React.createElement("video",{muted:!0,autoPlay:!0,playsInline:!0,loop:!0},React.createElement("source",{src:a,type:"video/mp4"})),t)},p.Image=function(e){var t=e.children,n=e.href,a=e.src,r=e.alt,s=i()(e,["children","href","src","alt"]);return React.createElement(p,o()({href:n||a},s),React.createElement("img",{src:a,alt:r}),t)},t.a=p},160:function(e,t,n){e.exports={figure:"styles-figure_23Vi",arrow:"styles-arrow_2C7-"}},166:function(e,t,n){"use strict";var a=n(19),o=n.n(a),r=n(7),i=n.n(r),s=n(167),c=n.n(s);function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}t.a=function(e){var t=e.src,n=e.autoScale,a=void 0===n||n,r=useState(0),s=i()(r,2),b=s[0],p=s[1],d=useState(1),u=i()(d,2),h=u[0],m=u[1],g=useState(!0),f=i()(g,2),j=f[0],O=f[1],w=useState(null),y=i()(w,2),v=y[0],x=y[1],N=useRef(),k=useRef(),T=useDebounce((function(){!function(){var e=k.current;if(e){var t=e.contentWindow.document.body;t&&p(t.scrollHeight)}}(),function(){var e=N.current;if(e&&a){var t=e.getBoundingClientRect().width;m(t/560)}}()}),40);useEffect((function(){return x(t)}),[t]),useEffect(T,[j]),useDelays(T,[200,500,1e3],[j]),useResize(T);var I=j?{}:{opacity:1,transition:"opacity 0.5s"},R={height:j?null:"".concat(b*h,"px")},A=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o()(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({height:"".concat(b,"px"),transform:"scale(".concat(h,")")},I);return React.createElement("div",{ref:N,className:c.a.frame,style:R},React.createElement("iframe",{ref:k,src:v,onLoad:function(){return O(!1)},style:A,scrolling:"no"}),j&&React.createElement("div",{className:c.a.loading}))}},167:function(e,t,n){e.exports={frame:"styles-frame_2QDX",loading:"styles-loading_2WpJ",fade:"styles-fade_1KOA"}},173:function(e,t,n){"use strict";n.r(t),t.default='import css from "./styles.scss";\n\nconst Aside = ({ target, children, moveDown = 0 }) => {\n  const [style, setStyle] = useState(null);\n\n  const align = () => {\n    const current = target.current;\n    if (!current) return; // Guard a race condition.\n\n    const rectangle = current.getBoundingClientRect();\n    const offset = window.scrollY + rectangle.top + moveDown;\n\n    setStyle({ top: offset, opacity: 1, transition: "opacity 0.3s" });\n  };\n\n  useEffect(align, []);\n  usePrint(align);\n\n  const alignSoon = useDebounce(align, 50);\n\n  useResize(alignSoon);\n  useDelays(alignSoon, [200, 500, 1000, 2500, 5000, 15000, 30000]);\n\n  return (\n    <aside className={css.aside} style={style}>\n      {children}\n    </aside>\n  );\n};\n\nexport default Aside;\n'},75:function(e,t,n){"use strict";n.r(t),n.d(t,"r",(function(){return a})),n.d(t,"r2",(function(){return o})),n.d(t,"r3",(function(){return r})),n.d(t,"title",(function(){return O})),n.d(t,"path",(function(){return w})),n.d(t,"type",(function(){return y})),n.d(t,"description",(function(){return v})),n.d(t,"keywords",(function(){return x})),n.d(t,"image",(function(){return N})),n.d(t,"video",(function(){return k})),n.d(t,"date",(function(){return T})),n.d(t,"default",(function(){return R}));var a,o,r,i=n(6),s=n.n(i),c=n(24),l=n.n(c),b=(n(0),n(25)),p=n(161),d=n(162),u=n(163),h=n(67),m=n(164),g=n(165),f=n(159),j=n(166),O="Building a commentary sidebar in React (cont.)",w="/blog/react-commentary-sidebar-2",y="article",v="Part two of building a commentary sidebar in React: taking a deeper look at the code.",x="Chris Patuzzo,React,commentary,sidebar,aside,hooks,printing,bug",N={path:"/images/commentary-sidebar.gif",width:600,height:478,bytes:904040,type:"image/gif"},k={path:"/videos/commentary-sidebar.mp4",width:1120,height:892,bytes:531454,type:"video/mp4"},T="2019-10-30T12:01Z",I={r:a,title:O};function R(e){var t=e.components,i=l()(e,["components"]);return Object(b.b)("wrapper",s()({},I,i,{components:t,mdxType:"MDXLayout"}),Object(b.b)(u.a,s()({title:O,path:w,type:y,description:v,keywords:x,image:N,video:k},{mdxType:"MetaTags"})),Object(b.b)(h.a,{previous:p.reactCommentarySidebar,next:p.grapplingWithInfinity,mdxType:"NavBar"}),Object(b.b)("title",null,O),Object(b.b)("h1",null,O),Object(b.b)("time",{dateTime:T},"Published ",Object(d.a)(T)," by "," ",Object(b.b)("a",{href:"https://twitter.com/chrispatuzzo"},"Chris Patuzzo"),Object(b.b)(m.a,{mdxType:"FeedIcon"})),Object(b.b)("div",{className:"note"},"This is the second of two parts. Part one is ",Object(b.b)("a",{href:"/blog/react-commentary-sidebar"},"here"),"."),Object(b.b)("p",null,"In part one, we created a sidebar that lets us comment on articles. We built a\nReact component that auto-aligns itself with specific words or phrases. The\n",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," component binds a listener in case the window is resized:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),'const Aside = ({ target, children, moveDown }) => {\n  const [style, setStyle] = useState(null);\n\n  const align = () => {\n    const rectangle = target.current.getBoundingClientRect();\n    const offset = window.scrollY + rectangle.top + moveDown;\n\n    setStyle({ top: offset });\n  };\n\n  useEffect(() => {\n    align(); // Align when the component is mounted.\n\n    const listener = window.addEventListener("resize", align);\n    return () => window.removeEventListener("resize", listener);\n  }, []);\n\n  return (\n    <aside className={css.aside} style={style}>\n      {children}\n    </aside>\n  );\n};\n\nexport default Aside;\n')),Object(b.b)("p",null,"Continuing from where we left off")),Object(b.b)(g.a,{target:a,moveDown:80,mdxType:"Aside"},Object(b.b)("p",null,"This includes the ",Object(b.b)("inlineCode",{parentName:"p"},"moveDown")," property which moves the comment down by an\nadditional fixed amount.")),Object(b.b)("p",null,"In ",Object(b.b)("span",{ref:a=createRef()},"this")," part, we’ll extend the component\nwith additional functionality to make it more robust and better-able to cope\nwith slow-loading content, print layouts, etc."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"We’ll also add some polish with a sweet CSS fade in animation.")),Object(b.b)("h2",null,"Slow-loading content"),Object(b.b)("p",null,"Currently the component positions itself when mounted, but what happens if\nimages and fonts take a few seconds to load asynchronously? They might affect\nthe layout by pushing content down, throwing our comments out of alignment.\nSomething like this:"),Object(b.b)(j.a,{src:"/examples/sidebar-3/example.html",autoScale:!1,mdxType:"Frame"}),Object(b.b)("p",null,"What we really want is for comments to re-align themselves after images and\nother slow-loading content has loaded. How can we get this to work?"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)(j.a,{src:"/examples/sidebar-3/example.html?align",autoScale:!1,mdxType:"Frame"}),Object(b.b)("p",null,"Re-aligning comments after images have loaded")),Object(b.b)(g.a,{target:a,moveDown:75,mdxType:"Aside"},Object(b.b)("p",null,"Actually, if you refresh this page you’ll see these frames are examples of\nslow-loading content.")),Object(b.b)("p",null,"We could try and listen in to these events but that would mean polluting our app\nwith event listeners for all manner of things: we’d have to register ",Object(b.b)("inlineCode",{parentName:"p"},"onLoad"),"\nevents for images and try to use the\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API"}),"Font Loading API")," to\ndetect when fonts have loaded."),Object(b.b)("p",null,"The simplest approach I’ve found is to just use timeouts re-align comments at\nset times in anticipation of slow-loading content. This is a ",Object(b.b)("em",{parentName:"p"},"hack")," and isn’t\nperfectly reliable, but I’ve found it works well enough in practice and it’s\neasy to implement:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const Aside = ({ target, children, moveDown = 0 }) => {\n  // ...\n\n  useEffect(() => {\n    const delays = [200, 500, 1000, 2500, 5000, 15000, 30000];\n    const timeouts = delays.map(d => window.setTimeout(callback, d));\n\n    return () => timeouts.forEach(t => window.clearTimeout(t));\n  }, []);\n\n  // ...\n};\n")),Object(b.b)("p",null,"Using timeouts to re-align ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," elements")),Object(b.b)(g.a,{target:a,moveDown:90,mdxType:"Aside"},"I re-align often early on as the page loads, then slow it down."),Object(b.b)("p",null,"There are cases where this approach won’t work. For example, if the user can\nexpand something on the page, the layout might change. We ",Object(b.b)("span",{ref:a=createRef()},"could")," additionally use ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," and periodically\nre-align elements every few seconds as well."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I don’t really like using ",Object(b.b)("inlineCode",{parentName:"p"},"setInterval")," if I can avoid it as it bloats the page.")),Object(b.b)("h3",null,"Hooks"),Object(b.b)("p",null,"To avoid cluttering our component, we can extract functionality into\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://reactjs.org/docs/hooks-intro.html"}),"React hooks"),":"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const useDelays = (callback, delays, dependencies = []) => {\n  useEffect(() => {\n    const timeouts = delays.map(d => window.setTimeout(callback, d));\n\n    return () => timeouts.forEach(t => window.clearTimeout(t));\n  }, dependencies);\n};\n\nexport default useDelays;\n")),Object(b.b)("p",null,"Extracting a hook to register the timeouts")),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"This hook optionally takes ",Object(b.b)("inlineCode",{parentName:"p"},"dependencies")," to make it more reusable, but we\ndon’t strictly need it for our ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," component.")),Object(b.b)("p",null,"While we’re at it, let’s do the same for our resize listener:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),'const useResize = (callback, dependencies = []) => {\n  useEffect(() => {\n    const listener = window.addEventListener("resize", callback);\n\n    return () => window.removeEventListener("resize", listener)\n  }, dependencies);\n};\n\nexport default useResize;\n')),Object(b.b)("p",null,"Extracting a hook to listen to the resize event")),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Again, this takes ",Object(b.b)("inlineCode",{parentName:"p"},"dependencies"),".")),Object(b.b)("p",null,"This neatens up our component considerably:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const Aside = ({ target, children, moveDown = 0 }) => {\n  // ...\n\n  useEffect(align, []); // Align when the component is mounted.\n  useResize(align);\n  useDelays(align, [200, 500, 1000, 2500, 5000, 15000, 30000]);\n\n  // ...\n};\n")),Object(b.b)("p",null,"A much tidier component that uses hooks")),Object(b.b)(g.a,{target:a,moveDown:73,mdxType:"Aside"},Object(b.b)("p",null,"My first pass at this component was a mess with ~100 lines of code. Hooks tidy things up a lot.")),Object(b.b)("p",null,"We’ll use this approach of extracting hooks to keep our component clean as we\nadd sophistication. It also means these behaviours are modular and can be\nreused later."),Object(b.b)("h2",null,"A race condition"),Object(b.b)("p",null,"Occasionally, when resizing the window, React would throw the following error:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/get-bounding-rect-error.png",alt:"getBoundingClientRect error"},"An error that sometimes happens on resize"),Object(b.b)(g.a,{target:a,moveDown:115,mdxType:"Aside"},"As I write this article, I keep seeing this image and think I’ve broken the code. It’s very off-putting."),Object(b.b)("p",null,"I think this happens because of a race condition between the resize event and\nReact’s event loop. Sometimes ",Object(b.b)("inlineCode",{parentName:"p"},"target")," refers to an ",Object(b.b)("inlineCode",{parentName:"p"},"undefined")," element."),Object(b.b)("p",null,"This ",Object(b.b)("span",{ref:a=createRef()},"shouldn’t")," be the case because the\nreferenced element always exists and is before the ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," in the DOM, but\nReact might be in the middle of re-rendering the component and hasn’t updated\nits ",Object(b.b)("inlineCode",{parentName:"p"},"ref")," yet. It throws an error when we try to use it."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I’m not sure this is actually the problem but it’s my best guess. I’m by no means a React expert.")),Object(b.b)("p",null,"We can fix this problem with a guard condition in the ",Object(b.b)("inlineCode",{parentName:"p"},"align")," function:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const align = () => {\n  const current = target.current;\n  if (!current) return; // Guard a race condition.\n\n  const rectangle = current.getBoundingClientRect();\n  const offset = window.scrollY + rectangle.top + moveDown;\n\n  setStyle({ top: offset });\n};\n")),Object(b.b)("p",null,"Fixing the problem by adding a guard clause")),Object(b.b)(g.a,{target:a,moveDown:15,mdxType:"Aside"},Object(b.b)("p",null,"We could probably extract this into some kind of hook, too. I don’t want to go\ntoo ",Object(b.b)("em",{parentName:"p"},"hook-crazy"),", though.")),Object(b.b)("h3",null,"Debouncing"),Object(b.b)("p",null,"The ",Object(b.b)("span",{ref:a=createRef()},"above")," error draws attention to the fact\nthat the browser fires hundreds of events when the window is resized. This\nexasperates the problem because React competes with the resize handler for\nexecution time, making the race condition more likely."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"An event is fired every time the dimensions of the window change, even by a small amount.")),Object(b.b)("p",null,"We’ve fixed the problem by guarding against it, but it’s probably sensible to\nalso reduce the number of re-alignments per second. There’s no need to re-align\nhundreds of times in a row as the user drags the edges of their browser to\nresize it."),Object(b.b)("p",null,"In the same spirit as before, we’ll use a hook for this:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const alignSoon = useDebounce(align, 50);\n\nuseResize(alignSoon);\nuseDelays(alignSoon, [200, 500, 1000, 2500, 5000, 15000, 30000]);\n")),Object(b.b)("p",null,"Wrapping the ",Object(b.b)("inlineCode",{parentName:"p"},"align")," function with a ",Object(b.b)("inlineCode",{parentName:"p"},"useDebounce")," hook")),Object(b.b)(g.a,{target:a,moveDown:35,mdxType:"Aside"},Object(b.b)("p",null,"We may as well debounce the timeouts as well in case the user is resizing at the same time.")),Object(b.b)("p",null,"Now ",Object(b.b)("span",{ref:a=createRef()},"when")," the user resizes their browser,\nthere will be a delay of 50 milliseconds before comments are re-aligned, vastly\nreducing the overhead of resizing."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"It’s not JavaScript that’s expensive, it’s changes to the DOM and styles that\ncause the page to re-render."),Object(b.b)("p",null,"That’s partly why React is so popular because it defers updates until necessary\nby using a ",Object(b.b)("a",s()({parentName:"p"},{href:"https://reactjs.org/docs/faq-internals.html"}),"virtual DOM"),".")),Object(b.b)("p",null,"This is noticeable, too. Before, when resizing the browser, the page was glitchy\nand slow to update. It’s much smoother with debouncing. I didn’t write the\ndebouncing implementation, I used\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://gist.github.com/mudge/eb9178a4b6d595ffde8f9cb31744afcf"}),"this one")," from\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://twitter.com/tomstuart"}),"Tom Stuart")," and\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://twitter.com/mudge"}),"Paul Mucur"),"."),Object(b.b)("h2",null,"Printing"),Object(b.b)("p",null,"Honestly, ",Object(b.b)("span",{ref:a=createRef()},"printing")," web pages is a mess.\nYou’d expect to get more-or-less the same version of the page you can see when\nyou hit print, but that’s not how it works. Instead, it’s ",Object(b.b)("a",s()({parentName:"p"},{href:"https://medium.com/freely-sharing-the-sum-of-all-knowledge/the-neglected-and-meandering-history-of-printing-websites-cf304824f9b1"}),"steeped in\nhistory"),"\nand works in arbitrary and unexpected ways."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"In Chrome and Firefox there is a way to print exactly what you see on screen but\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://superuser.com/questions/846082/how-to-get-wysiwyp-print-what-you-see-in-a-web-browser"}),"it’s hidden")," in dev tools.")),Object(b.b)("p",null,"For example, some browsers fire ",Object(b.b)("a",s()({parentName:"p"},{href:"https://caniuse.com/#feat=beforeafterprint"}),Object(b.b)("inlineCode",{parentName:"a"},"onbeforeprint")," and\n",Object(b.b)("inlineCode",{parentName:"a"},"onafterprint"))," events. There’s also\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList"}),"MediaQueryList"),"\nbut ",Object(b.b)("span",{ref:a=createRef()},"only"),"\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList#Browser_compatibility"}),"some browsers"),"\nsupport event listeners. Other browsers scale content down by default and\nremove backgrounds and images."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"This is good because it saves ink, I just wish it was standardised.")),Object(b.b)("h3",null,"Why do I care?"),Object(b.b)("p",null,"I don’t actually think anyone will print these pages. The reason I care is\nbecause printing has subsumed a feature people do actually use: exporting web\npages to PDF."),Object(b.b)("p",null,"I’d ",Object(b.b)("span",{ref:a=createRef()},"like")," to be able to offer downloadable\nversions of articles for offline reading or perhaps even produce a short ebook\nsomeday. It’d be nice to use all the features I’ve developed for this blog\nwithout having to familiarise myself with a new tool."),Object(b.b)(g.a,{target:a,moveDown:-6,mdxType:"Aside"},Object(b.b)("p",null,Object(b.b)("a",s()({parentName:"p"},{href:"https://github.com/fraserxu/electron-pdf"}),"electron-pdf")," looks to be a good\nchoice to automate the creation of PDFs from web pages. Alternatively,\n",Object(b.b)("a",s()({parentName:"p"},{href:"https://pptr.dev/"}),"Puppeteer")," has support for this.")),Object(b.b)("h3",null,"The problem"),Object(b.b)("p",null,"When I first tried to print, I found the alignment of comments in the sidebar\nwas slightly off. Everything was a bit lower than it should be and this was\nexaggerated further down with comments toward the end of the article. What’s\ngoing on?"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/wrong-print-alignment.png",alt:"Wrong print alignment",className:"more_space border"},"Incorrect alignment in Chrome’s print dialogue"),Object(b.b)(g.a,{target:a,moveDown:110,mdxType:"Aside"},Object(b.b)("p",null,"The red arrows point to the targets of the ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," elements. The comments are\nall slightly misaligned."),Object(b.b)("p",null,"At first I thought they were off by a fixed amount but it varies depending on\nwhich page you’re on.")),Object(b.b)("p",null,"I ",Object(b.b)("span",{ref:a=createRef()},"think")," what’s happening is a fresh version\nof the page is rendered when the print dialogue is opened. It changes the\nlayout of the page by scaling its content and setting margins but doesn’t\ntrigger a resize event to re-align the comments."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I also found ",Object(b.b)("a",s()({parentName:"p"},{href:"https://bugs.chromium.org/p/chromium/issues/detail?id=697233"}),"this bug"),"\nfrom 2017 which might be related. It doesn’t look like it’ll be fixed any time\nsoon.")),Object(b.b)("p",null,"You can control some things through print stylesheets and ",Object(b.b)("inlineCode",{parentName:"p"},"@media print")," style\nrules but it’s harder to reliably detect in JavaScript when the page is being\nprinted."),Object(b.b)("h3",null,"The solution"),Object(b.b)("p",null,"Eventually, I wrote another hook that works ",Object(b.b)("em",{parentName:"p"},"most")," of the time:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)("span",{ref:o=createRef()}),Object(b.b)("span",{ref:r=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),'const usePrint = (onChange) => {\n  const [isPrinting, setPrinting] = useState(false);\n\n  const handleChange = (printing) => {\n    if (printing === isPrinting) return;\n\n    setPrinting(printing);\n    onChange(printing);\n  };\n\n  useEffect(() => {\n    const beforeListener = window.addEventListener("beforeprint", () => handleChange(true));\n    const afterListener = window.addEventListener("afterprint", () => handleChange(false));\n\n    const printMedia = window.matchMedia("print");\n    const printListener = printMedia.addListener((e) => handleChange(e.matches));\n\n    return () => {\n      window.removeEventListener("beforeprint", beforeListener);\n      window.removeEventListener("afterprint", afterListener);\n\n      printMedia.removeListener(printListener);\n    };\n  });\n\n  return isPrinting;\n};\n\nexport default usePrint;\n')),Object(b.b)("p",null,"A React hook to detect print events")),Object(b.b)(g.a,{target:a,moveDown:50,mdxType:"Aside"},Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"handleChange")," only calls ",Object(b.b)("inlineCode",{parentName:"p"},"onChange")," if the state has actually changed. Some\nbrowsers fire multiple print events at once.")),Object(b.b)(g.a,{target:o,moveDown:270,mdxType:"Aside"},Object(b.b)("p",null,"Notice the slight interface difference?"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"addListener")," vs. ",Object(b.b)("inlineCode",{parentName:"p"},"addEventListener")),Object(b.b)("p",null,"I didn’t.")),Object(b.b)(g.a,{target:r,moveDown:500,mdxType:"Aside"},Object(b.b)("p",null,"I made it so the hook returns ",Object(b.b)("inlineCode",{parentName:"p"},"isPrinting"),", but I don’t actually use it in the\ncomponent.")),Object(b.b)("p",null,"I then use this hook in the ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," component to trigger a re-alignment. It’s\nimportant not to debounce these calls. If we do, the print dialogue blocks the\npage while it renders a print version and we’ve missed our slot."),Object(b.b)("p",null,"Here’s how use the hook:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),"const Aside = ({ target, children, moveDown = 0 }) => {\n  // ...\n\n  useEffect(align, []);\n  usePrint(align);  // Immediately call the function.\n\n  // ...\n};\n")),Object(b.b)("p",null,"Re-aligning ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," elements on print")),Object(b.b)(g.a,{target:a,moveDown:72,mdxType:"Aside"},"It took me a while to figure out not to debounce these calls."),Object(b.b)("p",null,"This hook isn’t perfect but it seems to work well in Chrome and Safari. I still\nneed to do more work to add a print stylesheet to make it look nice but at\nleast it’s no longer broken... except in Firefox which likes to overlap all the\ncomments:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/firefox-broken-comments.png",alt:"Broken comments while printing in Firefox"},"Printing comments in Firefox is still broken"),Object(b.b)(g.a,{target:a,moveDown:85,mdxType:"Aside"},Object(b.b)("p",null,"This is how Firefox prints the comments for ",Object(b.b)("em",{parentName:"p"},"this")," article.")),Object(b.b)("p",null,"I’ll try to fix it someday but for now I’m happy it works in WebKit. That means\nI can produce prepared PDFs, rather than encourage ",Object(b.b)("em",{parentName:"p"},"anyone")," to use the print\ndialogue."),Object(b.b)("h2",null,"Final touches"),Object(b.b)("p",null,"It can look messy if ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," elements jump around a lot as the page loads.\nThis will happen a bit as slow-loading content is added to the page but we can\nsmooth things over a little by fading in our comments after the first alignment\nhas happened:"),Object(b.b)("pre",null,Object(b.b)("code",s()({parentName:"pre"},{className:"language-javascript"}),'const align() {\n  //...\n\n  setStyle({ top: offset, opacity: 1, transition: "opacity 0.3s" });\n}\n')),Object(b.b)("p",null,"Also, if you’re using ",Object(b.b)("inlineCode",{parentName:"p"},"<Aside>")," elements a lot, be mindful that each time you\ndo, even listeners are being registered on ",Object(b.b)("inlineCode",{parentName:"p"},"window"),". This can add up over time:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/many-resize-listeners.png",alt:"Many resize listeners",className:"border"},"Event listeners registered for the window"),Object(b.b)(g.a,{target:a,moveDown:100,mdxType:"Aside"},Object(b.b)("p",null,"You can see registered listeners in Chrome by inspecting any element, opening the ‘Event Listeners’ tab then selecting the ‘Ancestors’ option.")),Object(b.b)("p",null,"It ",Object(b.b)("span",{ref:a=createRef()},"would")," be better to register a single\nhandler for each type of event and re-align all comments through that. I\nhaven’t implemented this but will probably add this later."),Object(b.b)(g.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,Object(b.b)("a",s()({parentName:"p"},{href:"https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8"}),"This"),"\nlooks to be a good resource on how to do this using ",Object(b.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern"}),"PubSub"),"."),Object(b.b)("p",null,"Alternatively, you could use ",Object(b.b)("a",s()({parentName:"p"},{href:"https://redux.js.org/"}),"Redux"),".")),Object(b.b)("h3",null,"Final thoughts"),Object(b.b)("p",null,"In this article, we’ve taken a detailed look at how to build a commentary\nsidebar in React. This has a few rough edges but overall I’m really happy with\nhow it turned out."),Object(b.b)("p",null,"It’s already become an integral part of how I think about writing. A tool I can\nreach for when I want to say ",Object(b.b)("em",{parentName:"p"},"a little bit more")," about something, without being\ntoo distracting."),Object(b.b)("p",null,"I’m really enjoying the process of writing and learning React so it’s been fun\nto combine the two. For reference, here’s the most up to date version of the\ncode:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)("span",{ref:o=createRef()}),Object(b.b)("span",{ref:r=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",{className:"language-jsx"},n(173).default)),Object(b.b)("p",null,"  The ‘live’ version of the code powering this blog")),Object(b.b)(g.a,{target:a,moveDown:175,mdxType:"Aside"},Object(b.b)("p",null,"I might improve this code over time but this article should automatically update to reflect that.")),Object(b.b)(g.a,{target:o,moveDown:380,mdxType:"Aside"},Object(b.b)("p",null,"If you want to see the version of the code, frozen in time when this article was\nwritten, it’s ",Object(b.b)("a",s()({parentName:"p"},{href:"https://github.com/tuzz/tuzz.tech/blob/caa688d1847ae2db7c0c0376588a2431f281f220/components/aside/index.jsx"}),"here"),".")),Object(b.b)(g.a,{target:r,moveDown:590,mdxType:"Aside"},Object(b.b)("p",null,"Maybe I should explain how the live code embedding works, too? I’ll save that for another day.")),Object(b.b)(h.a,{previous:p.reactCommentarySidebar,next:p.grapplingWithInfinity,mdxType:"NavBar"}))}R.isMDXComponent=!0}}]);