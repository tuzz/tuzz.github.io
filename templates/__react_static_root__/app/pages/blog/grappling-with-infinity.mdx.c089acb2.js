(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{159:function(e,t,n){"use strict";var a=n(6),i=n.n(a),r=n(24),o=n.n(r),s=n(7),l=n.n(s),b=n(160),c=n.n(b),p=function(e){var t=e.children,n=e.href,a=e.className,i=l()(t,2),r=i[0],o=i[1],s=n?React.createElement("a",{href:n,target:"_blank"},r):r;return React.createElement("figure",{className:"".concat(a," ").concat(c.a.figure)},s,React.createElement("figcaption",null,React.createElement("span",{className:c.a.arrow},"▲"),React.createElement("span",null,o)))};p.Video=function(e){var t=e.children,n=e.href,a=e.src,r=o()(e,["children","href","src"]);return React.createElement(p,i()({href:n||a},r),React.createElement("video",{muted:!0,autoPlay:!0,playsInline:!0,loop:!0},React.createElement("source",{src:a,type:"video/mp4"})),t)},p.Image=function(e){var t=e.children,n=e.href,a=e.src,r=e.alt,s=o()(e,["children","href","src","alt"]);return React.createElement(p,i()({href:n||a},s),React.createElement("img",{src:a,alt:r}),t)},t.a=p},160:function(e,t,n){e.exports={figure:"styles-figure_23Vi",arrow:"styles-arrow_2C7-"}},70:function(e,t,n){"use strict";n.r(t),n.d(t,"r",(function(){return a})),n.d(t,"r2",(function(){return i})),n.d(t,"title",(function(){return g})),n.d(t,"path",(function(){return j})),n.d(t,"type",(function(){return O})),n.d(t,"description",(function(){return w})),n.d(t,"keywords",(function(){return y})),n.d(t,"image",(function(){return v})),n.d(t,"video",(function(){return x})),n.d(t,"date",(function(){return N})),n.d(t,"default",(function(){return k}));var a,i,r=n(6),o=n.n(r),s=n(24),l=n.n(s),b=(n(0),n(25)),c=n(161),p=n(162),m=n(163),u=n(67),h=n(164),d=n(165),f=n(159),g="Grappling with infinity in constraint solvers",j="/blog/grappling-with-infinity",O="article",w="How can we solve constraint-satisfaction problems that deal with infinite structure? This article is about Sentient, a programming language I wrote to solve tricky problems.",y="Chris Patuzzo,Constraint programming,Constraint solvers,Sentient,Infinity,Approximations,SAT,Satisfiability,NP-hard,Turing completeness,Loop unrolling",v={path:"/images/multi-dimensional-space.png",width:1556,height:1018,bytes:13652,type:"image/png"},x={path:"/videos/sum-of-squares-optimisation.mp4",width:1218,height:700,bytes:307345,type:"video/mp4"},N="2019-11-17T12:00Z",T={r:a,title:g};function k(e){var t=e.components,n=l()(e,["components"]);return Object(b.b)("wrapper",o()({},T,n,{components:t,mdxType:"MDXLayout"}),Object(b.b)(m.a,o()({title:g,path:j,type:O,description:w,keywords:y,image:v,video:x},{mdxType:"MetaTags"})),Object(b.b)(u.a,{previous:c.reactCommentarySidebar2,next:c.pairProgrammingInSentient,mdxType:"NavBar"}),Object(b.b)("title",null,g),Object(b.b)("h1",null,g),Object(b.b)("time",{dateTime:N},"Published ",Object(p.a)(N)," by "," ",Object(b.b)("a",{href:"https://twitter.com/chrispatuzzo"},"Chris Patuzzo"),Object(b.b)(h.a,{mdxType:"FeedIcon"})),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)("div",{className:"note"},Object(b.b)("p",null,"In 2016, I created a programming language called\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/"}),"Sentient"),". Since then, I’ve had time to reflect and\nthink about the language. This series is about that.")),Object(b.b)("p",null,'Many constraint-satisfaction problems deal with infinity in some shape or form.\nEven rudimentary problems, like "Find two integers that sum to 10". Solutions include:'),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"(4, 6)"),Object(b.b)("li",{parentName:"ul"},"(-7, 17)"),Object(b.b)("li",{parentName:"ul"},"(-1953856112, ",Object(b.b)("span",{ref:a=createRef()},"1953856122)"))),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"That (d)escalated quickly!")),Object(b.b)("p",null,"In fact, there are infinitely many solutions and infinitely many pairs of\nintegers to test. Here’s a ",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/"}),"Sentient")," program to\nsolve this problem:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a, b;\n\ninvariant a + b == 10;\n\nexpose a, b;\n")),Object(b.b)("p",null,"A Sentient program to find integers that sum to 10")),Object(b.b)(d.a,{target:a,moveDown:33,mdxType:"Aside"},Object(b.b)("p",null,"This article is about Sentient, but many of the concepts apply to constraint solvers in general.")),Object(b.b)("p",null,"We can run this with the ",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/cli/number"}),Object(b.b)("inlineCode",{parentName:"a"},"--number 0")," option"),",\nto continuously find solutions:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Video,{src:"/videos/sentient-sum-to-ten.mp4"},"Finding multiple solutions with Sentient"),Object(b.b)(d.a,{target:a,moveDown:270,mdxType:"Aside"},Object(b.b)("p",null,"When Sentient returns ",Object(b.b)("inlineCode",{parentName:"p"},"{}"),", it has exhausted the search space and can’t find any\nmore solutions.")),Object(b.b)("p",null,"After a few seconds this ",Object(b.b)("span",{ref:a=createRef()},"program")," terminates\nwhich seems ",Object(b.b)("em",{parentName:"p"},"wrong"),". Why should a problem that has infinitely many solutions\never terminate? Shouldn’t it run forever?"),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I sometimes use ‘program’ and ‘problem’ synonymously. Programs are descriptions of problems.")),Object(b.b)("p",null,"The simple answer is that integers in Sentient aren’t really integers as far as\nthe mathematical definition is concerned. Their magnitude is limited by how\nmany bits represent them. By ",Object(b.b)("span",{ref:a=createRef()},"default")," this is\n8 but can be specified, e.g. ",Object(b.b)("inlineCode",{parentName:"p"},"int9"),", ",Object(b.b)("inlineCode",{parentName:"p"},"int32")),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"int")," ranges from -128 to 127.")),Object(b.b)("p",null,"In many cases this is fine. We can pick a number of bits that’s ‘big enough’\nand not worry about it. But other times it’s not fine. We often want to start\nsmall and work our way up to larger representations, but that means restarting\nthe program each time."),Object(b.b)("p",null,"For some problems, solutions are extremely rare (or non-existent) and it could\ntake weeks or months for ",Object(b.b)("span",{ref:a=createRef()},"Sentient")," to find\none. In these cases, it makes sense to start with small representations and\nprogressively rule our search spaces of increasing size."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"A negative result for a small space is better than no result for a larger one.")),Object(b.b)("p",null,"Unfortunately, when a program is restarted, we lose its progress. Regions that\nwere already explored are explored again. If we increase ",Object(b.b)("inlineCode",{parentName:"p"},"int")," to ",Object(b.b)("inlineCode",{parentName:"p"},"int9"),",\nSentient finds new solutions but it also finds all the same solutions again.\nThis is wasteful."),Object(b.b)("p",null,"We could compensate by adding a constraint:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int9 a, b;\n\ninvariant a < -128 || a > 127 || b < -128 || b > 127;\n# ...\n")),Object(b.b)("p",null,"Eliminating the region we’ve already explored")),Object(b.b)("p",null,"But ",Object(b.b)("span",{ref:i=createRef()},"this")," becomes unwieldy, and for many\nproblems, isn’t easy to specify. It’s also a manual process and therefore\nerror-prone. Ideally, Sentient would offer first-class support for something\nlike this. I have some ideas about how that might work."),Object(b.b)(d.a,{target:a,moveDown:20,mdxType:"Aside"},Object(b.b)("p",null,"This specifies that ",Object(b.b)("inlineCode",{parentName:"p"},"a")," or ",Object(b.b)("inlineCode",{parentName:"p"},"b")," must lie outside the region already explored for\neight-bit integers.")),Object(b.b)(d.a,{target:i,mdxType:"Aside"},Object(b.b)("p",null,"In ",Object(b.b)("a",o()({parentName:"p"},{href:"https://github.com/tuzz/letterwise_magic_squares/blob/master/lib/letterwise_magic_squares/generator.rb"}),"some cases"),", I’ve\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://github.com/tuzz/number_chains/blob/master/lib/number_chain/generator.rb"}),"written scripts"),"\nto generate Sentient programs with integers of increasing size.")),Object(b.b)("h2",null,"Approximations"),Object(b.b)("p",null,"I’ve ",Object(b.b)("span",{ref:a=createRef()},"found")," a useful way to think about this\nis in terms of ",Object(b.b)("em",{parentName:"p"},"approximations"),". An eight-bit integer is really an\napproximation of the mathematical (infinite) version of an integer. Its domain\nis finite but as long as we stay within bounds, it behaves in the same way."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I’m using ‘approximation’ in a ",Object(b.b)("em",{parentName:"p"},"literal")," sense and not according to some precise\nmathematical definition.")),Object(b.b)("p",null,"Most of the time when we write computer programs we don’t have to think about\nthis because we deal with concretions. Variables are assigned concrete values\nand, provided we stay within range without overflowing, everything checks out."),Object(b.b)("p",null,"In our case, variables are ",Object(b.b)("span",{ref:a=createRef()},"‘symbolic’"),". We\ndon’t actually assign values to ",Object(b.b)("inlineCode",{parentName:"p"},"int a, b"),", we just tell Sentient they exist and\nspecify some constraints. Its job is to discover values for ",Object(b.b)("inlineCode",{parentName:"p"},"a, b"),", but it has\nto work with something tangible. It can’t reason about infinity."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"‘Symbolic’ is the term used by the ",Object(b.b)("a",o()({parentName:"p"},{href:"https://klee.github.io/"}),"KLEE")," project for\nthis concept.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Why ",Object(b.b)("span",{ref:a=createRef()},"can’t")," Sentient reason about infinity?")),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Great question!")),Object(b.b)("p",null,"Technically it could but currently, its implementation closely relates to the\nmechanism it uses for solving. Programs are compiled to instances of\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"}),"SAT")," which, by\ndefinition, are boolean equations that comprise finitely many variables and\nclauses."),Object(b.b)("p",null,"This ",Object(b.b)("span",{ref:a=createRef()},"doesn’t")," have to be the case, though.\nSentient could abstract over these equations and automatically introduce new\nvariables to represent larger integers."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I think of this as ",Object(b.b)("em",{parentName:"p"},"better approximating")," the infinite version of an integer.")),Object(b.b)("p",null,"Actually, ",Object(b.b)("span",{ref:a=createRef()},"Sentient")," does something similar to\nthis for the ",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/cli/number"}),Object(b.b)("inlineCode",{parentName:"a"},"--number")," option"),".\nSentient finds multiple solutions to problems by repeatedly solving the same\nequation. It introduces a new clause each time to ban the solution it just\nfound."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Sentient doesn’t solve these equations itself. It delegates to SAT solvers,\nsuch as ",Object(b.b)("a",o()({parentName:"p"},{href:"http://fmv.jku.at/lingeling/"}),"lingeling"),".")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Could we dynamically change the size of representations?")),Object(b.b)("p",null,"We could, but it’s not obvious how to do this. If a program declares multiple\nintegers, should we change their number of bits all at once or one by one? For\nexample, should we increase ",Object(b.b)("inlineCode",{parentName:"p"},"a")," and ",Object(b.b)("inlineCode",{parentName:"p"},"b")," to ",Object(b.b)("inlineCode",{parentName:"p"},"int9")," in one go, or ",Object(b.b)("inlineCode",{parentName:"p"},"a")," followed by\n",Object(b.b)("inlineCode",{parentName:"p"},"b")," ?"),Object(b.b)("p",null,"For some problems, there could by differences in magnitude that are important:"),Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a, b;\nint15 target;\n\ninvariant a * b == target;\n\nexpose a, b, target;\n")),Object(b.b)("p",null,"This ",Object(b.b)("span",{ref:a=createRef()},"program")," contains implicit knowledge\nthat multiplying two numbers in the range -128 to 127 results in a number in\nthe range -16,384 to 16,383. Every time we increase ",Object(b.b)("inlineCode",{parentName:"p"},"a")," and ",Object(b.b)("inlineCode",{parentName:"p"},"b"),"’s\nrepresentation by one bit we ",Object(b.b)("em",{parentName:"p"},"should probably")," increase ",Object(b.b)("inlineCode",{parentName:"p"},"target"),"’s by two."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Technically, we should use ",Object(b.b)("inlineCode",{parentName:"p"},"int16")," because -128 x -128 is 16,384 which lies just\noutside -2^14 to 2^14 - 1.")),Object(b.b)("p",null,"What’s more, we haven’t considered more complex cases. What about arrays of\nintegers or arrays of arrays? We also need to consider how Sentient\ncommunicates where it’s up to. Which regions of search space has it exhausted so\nfar?"),Object(b.b)("h3",null,"More infinity"),Object(b.b)("p",null,"Before we try to answer some of these questions, let’s first consider other\nplaces infinity might crop up. There’s an\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://www.youtube.com/watch?v=wymmCdLdPvM&list=PLt5AfwLFPxWJcqG5YM89Qes5gZdAFM4Q1"}),"excellent series"),"\non ",Object(b.b)("span",{ref:a=createRef()},"Numberphile")," about the problem of finding\nthree cubes that sum to a target number. Let’s use that to help reason."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Brady also talks about this problem to in ",Object(b.b)("a",o()({parentName:"p"},{href:"https://www.youtube.com/watch?v=7Bia-dNcBm4"}),"this video")," with Adam Savage.")),Object(b.b)("p",null,"Here’s a Sentient program to solve this problem:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a, b, c, target;\n\ninvariant a.cube + b.cube + c.cube == target;\n\nexpose a, b, c, target;\n")),Object(b.b)("p",null,"A program to find three cubes that sum to a target")),Object(b.b)(d.a,{target:a,moveDown:7,mdxType:"Aside"},Object(b.b)("p",null,"We could hardcode ",Object(b.b)("inlineCode",{parentName:"p"},"target"),", but this makes the program more general. We can\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/cli/assign"}),"assign its value")," at runtime.")),Object(b.b)("p",null,"Firstly, let’s say we want to generalise our program further. Instead of summing\nthree cubes together, it’d be nice if we were able to write a program that sums\n",Object(b.b)("inlineCode",{parentName:"p"},"N")," cubes. We could assign ",Object(b.b)("inlineCode",{parentName:"p"},"N")," at runtime if we want or leave it unspecified."),Object(b.b)("p",null,"This isn’t valid syntax, but such a program might look like:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"array<int> numbers;\nint target;\n\ninvariant numbers.map(*cube).sum == target;\n\nexpose numbers, target;\n")),Object(b.b)("p",null,"A program to find ",Object(b.b)("inlineCode",{parentName:"p"},"N")," cubes that sum to a target")),Object(b.b)(d.a,{target:a,moveDown:7,mdxType:"Aside"},Object(b.b)("p",null,"This isn’t valid because you have to specify the size of an array, e.g."),Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"array3<int> numbers;\n"))),Object(b.b)("p",null,"Furthermore, why should the exponent be fixed? It’d be wonderful if that too\ncould be assigned at runtime or left unspecified for an extra degree of freedom."),Object(b.b)("p",null,"That program might look like this:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"array<int> numbers;\nint target, exp;\n\ninvariant numbers.map(*pow, exp).sum == target;\n\nexpose numbers, target, exp;\n")),Object(b.b)("p",null,"A program to find ",Object(b.b)("inlineCode",{parentName:"p"},"N")," numbers raised to an exponent that sum to a target")),Object(b.b)(d.a,{target:a,moveDown:33,mdxType:"Aside"},Object(b.b)("p",null,"This deviates further from Sentient’s syntax as ",Object(b.b)("inlineCode",{parentName:"p"},"map")," doesn’t support passing\nargs to function pointers, but hopefully you get the idea.")),Object(b.b)("p",null,"Perhaps this is too generic, but consider this: In just four lines, we’d be\nable to write a program that can solve a broad class of\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Diophantine_equation"}),"diophantine equations"),".\nI find this ",Object(b.b)("span",{ref:a=createRef()},"tantalising"),". It would be a triumph\nof our ability to communicate intention to the machine."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"But can it be realised?")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"How does this fit with approximations?")),Object(b.b)("p",null,"If we consider these cases in the context of approximation, a fixed-size array\ncould be seen as an approximation of a general array of unlimited size. We could\napproximate a general array by running multiple versions of our program with\ndifferent sizes."),Object(b.b)("p",null,"There ",Object(b.b)("span",{ref:a=createRef()},"are")," infinitely many array sizes to try\nand infinitely many exponents. These cases differ slightly from before because\nthere’s no overlap in search space. Nine-bit integers ",Object(b.b)("em",{parentName:"p"},"contain")," all the\neight-bit integers, but ‘squares’ and ‘cubes’ are ",Object(b.b)("em",{parentName:"p"},"distinct")," problems."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Some approximations result in containment hierarchies, others define independent\nspaces.")),Object(b.b)("h2",null,"Multi-dimensional space"),Object(b.b)("p",null,"For each of these approximations, we can think of them as defining a dimension\nin space. For example, here’s a two-dimensional space for integers ",Object(b.b)("inlineCode",{parentName:"p"},"a")," and ",Object(b.b)("inlineCode",{parentName:"p"},"b"),":"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/multi-dimensional-space.png",alt:"Multi-dimensional space"},"Visualising approximations as dimensional space"),Object(b.b)("p",null,"The ",Object(b.b)("span",{ref:i=createRef()},"highlighted")," point is an instance of a\nSentient program with integers ",Object(b.b)("inlineCode",{parentName:"p"},"a")," and ",Object(b.b)("inlineCode",{parentName:"p"},"b")," approximated with nine and eight\nbits, respectively. The shaded region shows the space being considered which\nincludes integers with fewer bits. The axes go to infinity."),Object(b.b)(d.a,{target:a,moveDown:88,mdxType:"Aside"},Object(b.b)("p",null,"For approximations with distinct search spaces, there wouldn’t be a shaded\nregion - just a point or a line."),Object(b.b)("p",null,"Integer approximations define regions because ",Object(b.b)("inlineCode",{parentName:"p"},"int9")," contains ",Object(b.b)("inlineCode",{parentName:"p"},"int"),", ",Object(b.b)("inlineCode",{parentName:"p"},"int7"),",\n",Object(b.b)("inlineCode",{parentName:"p"},"int6"),", etc.")),Object(b.b)(d.a,{target:i,mdxType:"Aside"},Object(b.b)("p",null,"The size of ",Object(b.b)("em",{parentName:"p"},"this")," space isn’t representative of the search space which doubles\nin size each time we add a single bit to an approximation.")),Object(b.b)("p",null,"Each time we approximate an integer, this adds a new dimensions to our space. If\nwe run a Sentient program multiple times with different approximations, we can\nthink of this as defining a walk or a path through this multi-dimensional space."),Object(b.b)("h3",null,"Infinite-dimensional space"),Object(b.b)("p",null,"Our extremely general program above contains this line:"),Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"array<int> numbers;\n")),Object(b.b)("p",null,"Here there are two kinds of infinity. Arrays can have unlimited size and\nintegers can be arbitrarily large. This is problematic because we first need to\napproximate the size of the array and then approximate the integers within that\narray."),Object(b.b)("p",null,"The result of these two degrees of freedom is an infinite dimensional space\nwith a dimension for every possible size of array. The nth dimension in this\nspace defines how many bits are used to approximate the integer at position n in\nthe array."),Object(b.b)("p",null,"As we add more approximations, these spaces are compounded and this\nspatial ",Object(b.b)("span",{ref:a=createRef()},"metaphor")," starts to fall apart. I’m\nnot sure whether it’s useful to think about approximations in this way when we\ngo above a small number of dimensions."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"My head hurts when I think about arrays of arrays of integers.")),Object(b.b)("h2",null,"Incrementality"),Object(b.b)("p",null,"Now let’s turn back to the question of how to change approximations over time.\nThere doesn’t seem to be an obvious approach other than something naive like\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://whatis.techtarget.com/definition/round-robin"}),"round-robin"),".\nApproximations with overlapping / non-overlapping spaces complicate things\nfurther."),Object(b.b)("p",null,"It seems to me the most robust way to do this is to delegate these decisions to\nthe programmer. ",Object(b.b)("span",{ref:a=createRef()},"Define")," a ",Object(b.b)("em",{parentName:"p"},"protocol")," so that\na program can determine how approximations should change at various stages\nduring the search."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"This program could even ask for user-input to decide what to do.")),Object(b.b)("p",null,'For example, our program that "finds two integers that sum to ten" could\ninitially call an external program that instructs it how many bits to use for\nits approximations. ',Object(b.b)("span",{ref:a=createRef()},"Once")," the search space is\nexhausted, it could ask the program what to do next:"),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Or it could ask at time intervals, or after each solution is found.")),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Image,{src:"/images/approximation-protocol.png",alt:"A protocol for approximation"},"Using an external program to decide how approximations should change"),Object(b.b)(d.a,{target:a,moveDown:110,mdxType:"Aside"},Object(b.b)("p",null,"Sentient could send additional information to the program such as:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"the solutions that were found and how long it took"),Object(b.b)("li",{parentName:"ul"},"the impact on the search space of each approximation"),Object(b.b)("li",{parentName:"ul"},"whether approximations have overlapping spaces or not"))),Object(b.b)("p",null,"The ",Object(b.b)("span",{ref:a=createRef()},"protocol")," could even allow Sentient to\nspawn new processes and search distinct spaces in parallel. For example, it\ncould search for solutions to the ‘squares’ and ‘cubes’ problems concurrently\nwhile controlling approximations in each instance."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Historically, ",Object(b.b)("a",o()({parentName:"p"},{href:"https://dl.acm.org/citation.cfm?id=2901028"}),"it’s been difficult"),"\nto efficiently parallelise SAT solving so this strategy could work well.")),Object(b.b)("h3",null,"Incremental SAT"),Object(b.b)("p",null,"In the world of SAT solving, a mechanism already exists for communicating with\na ",Object(b.b)("span",{ref:a=createRef()},"solver")," during its search. It’s called the\n‘Re-entrant Incremental Satisfiability Application Program Interface’ and is\nreferred to by its reverse acronym ‘IPASIR’."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"IPASIR was first introduced in section 6.2 of ",Object(b.b)("a",o()({parentName:"p"},{href:"http://fmv.jku.at/papers/BalyoBiereIserSinz-AI-16.pdf#page=9"}),"this paper"),".")),Object(b.b)("p",null,"In fact, I wrote ",Object(b.b)("a",o()({parentName:"p"},{href:"https://github.com/tuzz/ipasir-sys"}),"a Rust crate")," not too\nlong ago for communicating via this interface. The advantage of using it is to\nspeed up solving problems that have been modified in small ways without having\nto restart the search from scratch each time:"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"It is possible to solve such problems independently, however this might be\nvery inefficient compared to an incremental SAT solver, which can reuse\nknowledge acquired while solving the previous instances.\n"," ",Object(b.b)("em",{parentName:"p"},"– ",Object(b.b)("a",o()({parentName:"em"},{href:"http://fmv.jku.at/papers/BalyoBiereIserSinz-AI-16.pdf#page=9"}),"SAT Race 2015")," (abbreviated)"))),Object(b.b)("p",null,"At present, Sentient doesn’t use IPASIR at all. It was fairly new when I wrote\nthe language but has wider adoption today. At the very least, it would speed up\nsearching for multiple solutions to problems, but I think it could help with\napproximations, too."),Object(b.b)("p",null,"Ideally, ",Object(b.b)("span",{ref:a=createRef()},"a")," single instance of a SAT problem\nwould live for the duration of a Sentient program. As approximations change, so\ntoo would the underlying boolean equation. That would allow a maximal amount of\ninformation or ‘knowledge’ to be reused."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"In theory, this would mean overlapping search spaces aren’t explored more than once.")),Object(b.b)("h3",null,"Representations"),Object(b.b)("p",null,"There ",Object(b.b)("span",{ref:a=createRef()},"are")," limitations on what you can do\nwith IPASIR, otherwise it would be very difficult for solvers to reuse\nknowledge from previous searches. For example, you can’t remove clauses but you\ncan instead make ‘assumptions’ that are short-lived."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"You can ",Object(b.b)("em",{parentName:"p"},"effectively")," remove clauses using assumptions by adding one to each\nclause you want to remove.")),Object(b.b)("p",null,"Some thought would need to go into how to represent approximations in a way\nthat allows them to change later. If we go from ",Object(b.b)("inlineCode",{parentName:"p"},"int")," to ",Object(b.b)("inlineCode",{parentName:"p"},"int9"),", we don’t want\nto have to throw everything out. It should be possible for approximations to\n‘grow’ or ‘shrink’."),Object(b.b)("p",null,"All of the operations we apply to integers need to be able to cope with a\nchanging ",Object(b.b)("span",{ref:a=createRef()},"number")," of bits. For example,\ninteger addition is modelled after ",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Adder_(electronics)#Ripple-carry_adder"}),"ripple-carry\nadders"),".\nIts clauses in the boolean equation would need to use assumptions in clever\nways."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I need to put way more thought into how this would work.")),Object(b.b)("p",null,"It may even be there are efficiency gains if we know in advance ",Object(b.b)("em",{parentName:"p"},"how"),"\napproximations will change. If they only ever grow, and by precisely two bits\neach time, perhaps there’s a more efficient way to structure these equations.\nI’m not sure."),Object(b.b)("h3",null,"NP-hard problems"),Object(b.b)("p",null,"One final thought about incrementality is it would allow Sentient to reach the\ndizzying heights of being able to solve\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/NP-hardness"}),"NP-hard")," problems. At present,\nSentient can’t solve optimisation problems. It doesn’t specifically search for\n",Object(b.b)("em",{parentName:"p"},"minimums")," or ",Object(b.b)("em",{parentName:"p"},"maximums"),"."),Object(b.b)("p",null,"However, ",Object(b.b)("span",{ref:a=createRef()},"you")," can ",Object(b.b)("em",{parentName:"p"},"effectively")," do this by\nrunning the same program multiple times. For example, let’s say you want to\nfind two numbers that sum to ten such that the sum of their squares is\nminimised. You could write a program like this:"),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"This isn’t an NP-hard problem since it can be solved with linear algebra but it demonstrates the point.")),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a, b, max;\n\nsum = a.square + b.square;\n\ninvariant a + b == 10;\ninvariant sum < max;\n\nexpose a, b, sum, max;\n")),Object(b.b)("p",null,"Solving an optimisation problem with Sentient")),Object(b.b)(d.a,{target:a,moveDown:60,mdxType:"Aside"},Object(b.b)("p",null,"A more realistic optimisation problem would be\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Travelling_salesman_problem"}),"Travelling Salesman"),"\nor the ",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Knapsack_problem"}),"Knapsack")," problem.")),Object(b.b)("p",null,"You could then run this multiple times, reducing ",Object(b.b)("inlineCode",{parentName:"p"},"max")," until there are no\nsolutions:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a.Video,{src:"/videos/sum-of-squares-optimisation.mp4"},Object(b.b)("p",null,"Finding the optimal solution over repeated runs")),Object(b.b)(d.a,{target:a,moveDown:100,mdxType:"Aside"},Object(b.b)("p",null,"This finds the optimal solution ",Object(b.b)("inlineCode",{parentName:"p"},"{ a: 5, b: 5 }")," whose sum of squares is 50\nwhich is minimal."),Object(b.b)("p",null,"The video is sped up slightly.")),Object(b.b)("p",null,"I’m not sure whether my definition of approximations extends to optimisation\nproblems but there’s definitely an opportunity to use incrementality in a\nnumber of useful ways."),Object(b.b)("h2",null,"Turing-completeness"),Object(b.b)("p",null,"While we’re on the topic of NP-hard problems, it’s probably worth saying a few\nthings about computability and Turing completeness. On the ",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/intro/experimental"}),"Sentient\nwebsite")," I wrote this:"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"In fact, Sentient isn’t Turing complete. It is a Total programming language –\nit is fully decidable and does not suffer the Halting problem. That\ndrastically limits what it can do. For example, recursive function calls are\nnot supported and ",Object(b.b)("span",{ref:a=createRef()},"never")," will be.")),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"Never say never!")),Object(b.b)("p",null,"In fact, through the lens of approximations, it may be possible for Sentient to\nbecome Turing complete. At present, Sentient doesn’t support recursive function\ncalls:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a;\n\nfunction factorial (n) {\n  return n > 0 ? n * factorial(n - 1) : 1;\n};\n\ninvariant a.factorial > 150;\n\nexpose a;\n")),Object(b.b)("p",null,"A hypothetical Sentient program using recursion")),Object(b.b)(d.a,{target:a,moveDown:80,mdxType:"Aside"},Object(b.b)("p",null,"The smallest solution is ",Object(b.b)("inlineCode",{parentName:"p"},"{ a: 6 }")," because ",Object(b.b)("inlineCode",{parentName:"p"},"6! = 720 > 150"),".")),Object(b.b)("p",null,"A recursive function call can be approximated by limiting its depth of\nrecursion. For example, if ",Object(b.b)("inlineCode",{parentName:"p"},"factorial")," were approximated with a depth of 5 (or\nless), it wouldn’t find a solution but improving this to 6 would. Similarly, you\ncan’t do this at the moment:"),Object(b.b)("span",{ref:a=createRef()}),Object(b.b)(f.a,{mdxType:"Figure"},Object(b.b)("pre",null,Object(b.b)("code",o()({parentName:"pre"},{className:"language-sentient"}),"int a;\n\nsum = 0;\na.times(function^ () { sum += 3; });\n\ninvariant sum > 10;\n\nexpose a;\n")),Object(b.b)("p",null,"Another hypothetical program that isn’t allowed")),Object(b.b)(d.a,{target:a,moveDown:33,mdxType:"Aside"},Object(b.b)("p",null,"The ",Object(b.b)("a",o()({parentName:"p"},{href:"https://sentient-lang.org/library/integer#times"}),"#times")," method calls the\nfunction ",Object(b.b)("inlineCode",{parentName:"p"},"a")," times. It’s borrowed from Ruby."),Object(b.b)("p",null,"The ",Object(b.b)("inlineCode",{parentName:"p"},"^")," modifier lets the function access variables defined outside.")),Object(b.b)("p",null,"Sentient throws an error when you try to run this program:"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"Called ‘times’ with ‘a’ but ‘times’ only supports integer literals (arg #0)")),Object(b.b)("p",null,"This ",Object(b.b)("span",{ref:a=createRef()},"isn’t")," supported because ",Object(b.b)("inlineCode",{parentName:"p"},"a")," is\n‘symbolic’. Sentient is unable to compile this program to a boolean equation\nbecause the size of that equation can’t be determined. Its structure isn’t\nfixed. The ",Object(b.b)("inlineCode",{parentName:"p"},"#times")," method only works with ‘integer literals’ like ",Object(b.b)("inlineCode",{parentName:"p"},"5"),"."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},"This is one of a few places where Sentient differentiates between ‘symbolic’ and ‘literal’ variables."),Object(b.b)("p",null,"Again, we could solve this problem with approximations by limiting the value\nfor ",Object(b.b)("inlineCode",{parentName:"p"},"a"),"."),Object(b.b)("h3",null,"Loop unrolling"),Object(b.b)("p",null,"This ",Object(b.b)("span",{ref:a=createRef()},"technique")," is already used in various\nforms. Compilers frequently unroll loops and recursive function calls for\nperformance reasons.  ",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Model_checking"}),"Model\ncheckers")," perform static analysis\nto check invariants, often using techniques established in ",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Hoare_logic"}),"Hoare\nlogic"),"."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I was fortunate enough to see Tony Hoare at a conference which I spoke about in\nepisode 12 of ",Object(b.b)("a",o()({parentName:"p"},{href:"https://makercasts.org/podcasts/my-floc-experience/"}),"this podcast"),".")),Object(b.b)("p",null,"I see loop unrolling as another kind of approximation. Recursive functions could\nbe identified through static analysis and an external program could decide how\nmany calls are allowed for the current instance of the search."),Object(b.b)("p",null,"In ",Object(b.b)("span",{ref:a=createRef()},"theory"),", these techniques would allow\nSentient to be Turing complete in a sense. This combined with incremental SAT\ncould make for an extremely powerful system. The ability to solve problems\nrelating to arbitrary Turing machines would be amazing."),Object(b.b)(d.a,{target:a,mdxType:"Aside"},Object(b.b)("p",null,"I explored this a bit in ",Object(b.b)("a",o()({parentName:"p"},{href:"https://github.com/tuzz/machine_maker"}),"this project"),"\nwhich reduces Turing machines to SAT, as per the\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem"}),"Cook-Levin theorem"),".")),Object(b.b)("h3",null,"Where next?"),Object(b.b)("p",null,"I’m not sure. I’d like to play with these ideas more and perhaps some day\nincorporate them into Sentient or something else. There are clearly challenges\nwith incrementality and interface design but I think I’m on the right track."),Object(b.b)("p",null,"This is the first in-depth article I’ve written about Sentient and constraint\nsolving but hopefully there’s more to come. I’ll announce future updates\n",Object(b.b)("a",o()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo"}),"on Twitter"),"\nif you want to hear more. Follows are always appreciated. Thanks."),Object(b.b)(u.a,{previous:c.reactCommentarySidebar2,next:c.pairProgrammingInSentient,mdxType:"NavBar"}))}k.isMDXComponent=!0}}]);