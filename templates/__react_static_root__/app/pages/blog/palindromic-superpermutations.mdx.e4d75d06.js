(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{159:function(e,t,a){"use strict";var n=a(6),r=a.n(n),s=a(24),i=a.n(s),o=a(7),c=a.n(o),h=a(160),p=a.n(h),b=function(e){var t=e.children,a=e.href,n=e.className,r=c()(t,2),s=r[0],i=r[1],o=a?React.createElement("a",{href:a,target:"_blank"},s):s;return React.createElement("figure",{className:"".concat(n," ").concat(p.a.figure)},o,React.createElement("figcaption",null,React.createElement("span",{className:p.a.arrow},"▲"),React.createElement("span",null,i)))};b.Video=function(e){var t=e.children,a=e.href,n=e.src,s=i()(e,["children","href","src"]);return React.createElement(b,r()({href:a||n},s),React.createElement("video",{muted:!0,autoPlay:!0,playsInline:!0,loop:!0},React.createElement("source",{src:n,type:"video/mp4"})),t)},b.Image=function(e){var t=e.children,a=e.href,n=e.src,s=e.alt,o=i()(e,["children","href","src","alt"]);return React.createElement(b,r()({href:a||n},o),React.createElement("img",{src:n,alt:s}),t)},t.a=b},160:function(e,t,a){e.exports={figure:"styles-figure_23Vi",arrow:"styles-arrow_2C7-"}},74:function(e,t,a){"use strict";a.r(t),a.d(t,"r",(function(){return n})),a.d(t,"title",(function(){return f})),a.d(t,"path",(function(){return g})),a.d(t,"type",(function(){return j})),a.d(t,"description",(function(){return w})),a.d(t,"keywords",(function(){return O})),a.d(t,"image",(function(){return y})),a.d(t,"video",(function(){return v})),a.d(t,"date",(function(){return T})),a.d(t,"default",(function(){return N}));var n,r=a(6),s=a.n(r),i=a(24),o=a.n(i),c=(a(0),a(25)),h=a(161),p=a(162),b=a(163),l=a(67),u=a(164),m=a(165),d=a(159),f="Searching for palindromic superpermutations",g="/blog/palindromic-superpermutations",j="article",w="I wrote a search algorithm to tackle a challenging combinatorial problem.",O="Chris Patuzzo,superpermutation,search algorithm,depth first,Chaffin method,palindrome,branch and bound,incremental search,combinatorics",y={path:"/images/chaffin-search.gif",width:800,height:435,bytes:350969,type:"image/gif"},v={path:"/videos/chaffin-search.mp4",width:1280,height:696,bytes:237393,type:"video/mp4"},T="2019-10-20T12:00Z",k={r:n,title:f};function N(e){var t=e.components,a=o()(e,["components"]);return Object(c.b)("wrapper",s()({},k,a,{components:t,mdxType:"MDXLayout"}),Object(c.b)(b.a,s()({title:f,path:g,type:j,description:w,keywords:O,image:y,video:v},{mdxType:"MetaTags"})),Object(c.b)(l.a,{previous:h.addingBashCompletion,next:h.reactCommentarySidebar,mdxType:"NavBar"}),Object(c.b)("title",null,f),Object(c.b)("h1",null,f),Object(c.b)("time",{dateTime:T},"Published ",Object(p.a)(T)," by "," ",Object(c.b)("a",{href:"https://twitter.com/chrispatuzzo"},"Chris Patuzzo"),Object(c.b)(u.a,{mdxType:"FeedIcon"})),Object(c.b)("div",{className:"note"},"This is the first of two parts. The second will be available in a couple of weeks."),Object(c.b)(d.a.Video,{src:"/videos/chaffin-search.mp4",className:"more_space"},"Running my Rust-powered search algorithm"),Object(c.b)("p",null,"A superpermutation is a string of numbers that contains every permutation of\nthose numbers. For example, ‘123121321’ contains all ",Object(c.b)("span",{ref:n=createRef()},"six")," permutations of three numbers:"),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"123, 231, 312, 213, 132 and 321."),Object(c.b)("p",null,"One way to construct a superpermutation is to concatenate all N! permutations\ntogether but this is wasteful. We’d end up with a ",Object(c.b)("span",{ref:n=createRef()},"string")," of length 18 instead of 9:"),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"‘123231312213132321’"),Object(c.b)("p",null,"The ",Object(c.b)("em",{parentName:"p"},"trick")," is to try and overlap permutations as much as possible. ",Object(c.b)("span",{ref:n=createRef()},"Most")," of the time, when we add a character this\nalso add a permutation, but not always. A ‘greedy’ algorithm works fairly well\nto find ",Object(c.b)("em",{parentName:"p"},"short")," strings, but they might not be optimal."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"A ‘greedy’ approach is short sighted in that it picks characters that seem like good choices now but end up costing more in the long run."),Object(c.b)("p",null,"So the question is: ",Object(c.b)("strong",{parentName:"p"},"how short can these strings be?")),Object(c.b)("p",null,"Many people are trying to figure that out, either constructively, by\nexhaustive search for the shortest string, or non-constructively, by proof of\nits exact ",Object(c.b)("span",{ref:n=createRef()},"length"),". Ideally, we’d come up with\nan efficient process to build the shortest possible string."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"It might be this problem is ",Object(c.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/NP-hardness"}),"NP-hard")," and no efficient process exists.")),Object(c.b)("p",null,"I’m certainly no mathematician so I won’t tackle a proof, but I do know some\nthings about writing efficient search algorithms. In this article I’ll explain\nmy recent attempt to find ",Object(c.b)("strong",{parentName:"p"},"minimal ",Object(c.b)("span",{ref:n=createRef()},"superpermutations"))," - in this case, those that happen to be\npalindromes."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"A palindrome is a string that’s the same forwards and backwards."),Object(c.b)("p",null,"Along the way I wrote some C and Rust code. I’ll focus on the high-level\napproach in this article and save a detailed walk-through of the code for the\nnext."),Object(c.b)("h3",null,"Why palindromes?"),Object(c.b)("p",null,"In general, minimal superpermutations need not be palindromes. It so ",Object(c.b)("span",{ref:n=createRef()},"happens")," for N=1 to 4 they ",Object(c.b)("em",{parentName:"p"},"are"),", but no one has\nproved whether or not this is always true. In fact, for N=5 there are\n",Object(c.b)("a",s()({parentName:"p"},{href:"https://raw.githubusercontent.com/superpermutators/superperm/master/superpermutations/5/153-chaffin.txt"}),Object(c.b)("em",{parentName:"a"},"eight")," shortest strings"),"\ntied at 153 characters - one of which is a palindrome."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"For N=6, no one knows! The best strings so far have 872 characters, none of\nwhich are palindromes.")),Object(c.b)("p",null,"I decided to limit my search to palindromes because I think there’s fair chance\nthe ",Object(c.b)("span",{ref:n=createRef()},"shortest")," superpermutation ",Object(c.b)("em",{parentName:"p"},"is")," a\npalindrome and this lets us reduce the search space, making the problem more\ntractable. ",Object(c.b)("strong",{parentName:"p"},"Otherwise, the search might never finish.")),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"For the last few a months a ",Object(c.b)("a",s()({parentName:"p"},{href:"http://www.supermutations.net/ChaffinMethodResults/"}),"large distributed search"),"\nhas been trying to solve the general case for N=6.")),Object(c.b)("p",null,"Actually, I wholly expect the search not to finish anyway - even with this\nlimitation. I’m going to run it for a month or two on the N=6 problem to see\nhow far it gets, but I have low expectations. The ",Object(c.b)("a",s()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo/status/1067403432674435072"}),"combinatorial\nabyss")," is vast and\nunforgiving."),Object(c.b)("h3",null,"No repetition"),Object(c.b)("p",null,"There’s one more assumption I’m going to make about minimal superpermutations.\nThat is: they do not contain the same permutation more than once. In other\nwords, each and every permutation appears exactly once in the string, with no\nrepetition."),Object(c.b)("p",null,"Again, there’s no proof of this, but there’s mounting evidence this is the case.\nFor the N=6 problem, ",Object(c.b)("a",s()({parentName:"p"},{href:"https://docs.google.com/spreadsheets/d/1m8mHizDHoDpT-9ohCiqmfKyQI6gmhuyuzb7TC7362Ko/edit#gid=0"}),"more than ten\nthousand"),"\nstrings have been found with the shortest known length of 872. As far as I’m\naware none of these repeat a permutation."),Object(c.b)("p",null,"With ",Object(c.b)("span",{ref:n=createRef()},"this")," assumption in place, we can prune\nstrings from our search that contain repetition - reducing the search space.\nThis improves our chances of success."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"It might seem arbitrary to do this. We’ll see shortly how the benefits of this assumption are compounded when searching for palindromes."),Object(c.b)("h2",null,"How it works"),Object(c.b)("p",null,"At a high level, the algorithm works by searching for the shortest string that\ncontains exactly half the permutations. This string must also have the special\nproperty that its reversal contains precisely the ",Object(c.b)("em",{parentName:"p"},"other half")," of the\npermutations (the ones it’s missing)."),Object(c.b)("p",null,"When this string is ",Object(c.b)("span",{ref:n=createRef()},"glued")," together with its\nreversal, it forms a palindrome that is a superpermutation - a string that\ncontains all N! permutations."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"We overlap the last character of the string with the first of its reversal."),Object(c.b)("p",null,"For example, ‘12312’ contains 123, 231 and 312 which are three of the six\npermutations for N=3. Its reversal ‘21321’ contains 213, 132 and 321 which are\nprecisely the ",Object(c.b)("em",{parentName:"p"},"other three")," permutations it’s missing so it has the property we\nwant."),Object(c.b)("p",null,"That means we can glue ‘12312’ and ‘21321’ together to obtain ",Object(c.b)("span",{ref:n=createRef()},"‘123121321’")," which now contains all N! permutations - making\na (palindromic) superpermutation."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"We overlap the ‘2’ in the middle."),Object(c.b)("h3",null,"Depth-first search"),Object(c.b)("p",null,"The ",Object(c.b)("span",{ref:n=createRef()},"search")," is depth first, starting from the\n12...N permutation. This can be thought of as the root node of a search tree.\nAt each step, we ‘expand’ one string by adding a single character to the end of\nit. This adds a child node to the search tree."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"The code doesn’t explicitly build a search tree. It manifests itself through recursive function calls. I just find it useful to think in this way."),Object(c.b)("p",null,"From Wikipedia: “A depth-first search explores as far as possible along each\nbranch before backtracking.” When we translate that definition to this problem,\nit means we should expand longer and longer strings before backtracking to\nexpand shorter ones:"),Object(c.b)("span",{ref:n=createRef()}),Object(c.b)(d.a,{mdxType:"Figure"},Object(c.b)("pre",null,Object(c.b)("code",s()({parentName:"pre"},{className:"language-bash"}),"                1234\n                /  \\\n             12341  (not expanded yet)\n             /\n          123412\n          /\n      1234121\n       /\n     ...\n")),Object(c.b)("p",null,"A depth-first search starting from the ‘1234’ root node")),Object(c.b)(m.a,{target:n,moveDown:30,mdxType:"Aside"},Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"Why depth-first search?")),Object(c.b)("p",null,"The main reason is to find long strings early on in the search to learn about\nthe problem’s structure."),Object(c.b)("p",null,"We’ll see in the ‘Chaffin’ section how to use these learnings to our advantage\nto speed up the search."),Object(c.b)("p",null,"In other projects, I’ve tried different algorithms\n(",Object(c.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/A*_search_algorithm"}),"A*"),",\nreduction to ",Object(c.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"}),"SAT"),") which I\nmight write about later.")),Object(c.b)("p",null,"There’s still the question of when to backtrack. This is where our ‘No repeats’\nassumption comes into play. When a string is expanded, we check:"),Object(c.b)("ol",null,Object(c.b)("li",{parentName:"ol"},"Is the tail of the string a permutation?"),Object(c.b)("li",{parentName:"ol"},"If so, have we seen it before?")),Object(c.b)("p",null,"If the answer is ",Object(c.b)("em",{parentName:"p"},"yes")," we ",Object(c.b)("span",{ref:n=createRef()},"backtrack"),". There’s\nno point expanding the string further since we’re not interested in\nsuperpermutations that contain repetition."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"Backtracking is really good! It eliminates regions of search space that can’t possibly bear fruit."),Object(c.b)("h3",null,"The magic"),Object(c.b)("p",null,"However, we can go one step further! We know we’re going to glue this string to\nits reversal. That means ",Object(c.b)("strong",{parentName:"p"},"all permutations seen so far will be seen again")," -\nbut in reverse. Our assumption is each permutation appears once in the\n",Object(c.b)("em",{parentName:"p"},"entirety")," of the string."),Object(c.b)("p",null,"That means ",Object(c.b)("strong",{parentName:"p"},"we can check the tail of the string a second time"),". If we’ve seen\nits reversal before we can backtrack as well. This pre-empts the repetition\nthat ",Object(c.b)("em",{parentName:"p"},"would occur")," when the string is glued later. This lets us eliminate even\nmore ",Object(c.b)("span",{ref:n=createRef()},"strings!")),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"We can see the future."),Object(c.b)("p",null,"Here’s what the code might look like:"),Object(c.b)("span",{ref:n=createRef()}),Object(c.b)(d.a,{mdxType:"Figure"},Object(c.b)("pre",null,Object(c.b)("code",s()({parentName:"pre"},{className:"language-rust"}),"if permutations_seen[tail_of_string] {\n  return; // backtrack\n}\n\ntail_of_string.reverse();\n\nif permutations_seen[tail_of_string] {\n  return; // backtrack\n}\n")),Object(c.b)("p",null,"Backtracking if we’ve seen the tail of string in reverse")),Object(c.b)(m.a,{target:n,moveDown:85,mdxType:"Aside"},Object(c.b)("p",null,"In Rust, the ",Object(c.b)("a",s()({parentName:"p"},{href:"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reverse"}),Object(c.b)("inlineCode",{parentName:"a"},".reverse()"))," function mutates in place.")),Object(c.b)("p",null,"I think of this as the ",Object(c.b)("em",{parentName:"p"},"magic")," of this approach. It’s this combination of ideas\nthat initially motivated me to try writing the search algorithm. Whether or not\nit makes a significant dent in the problem remains to be seen but it’s worth a\nshot."),Object(c.b)("p",null,"Finally, there’s one last piece we need to supercharge the search algorithm."),Object(c.b)("h2",null,"The ‘Chaffin’ method"),Object(c.b)("p",null,"The search incorporates a clever technique devised by Benjamin Chaffin. The\nbasic idea is to break the problem into a ",Object(c.b)("span",{ref:n=createRef()},"sequence")," of subproblems. We can then use the solution to\nthe first subproblem to speed up solving the second, and so on."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"This is an example of ",Object(c.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Incremental_heuristic_search"}),"incremental heuristic search"),".")),Object(c.b)("p",null,"Each subproblem is stated in terms of ‘wasted’ characters. A wasted character\nis one that doesn’t add a new permutation itself but instead, prepares the\nstring so the next character can add a permutation. Sometimes more than one in a\nrow is needed."),Object(c.b)("p",null,"For ",Object(c.b)("span",{ref:n=createRef()},"example"),", when ‘1’ is appended to ‘12312’\nwe get ‘123121’. The ‘1’ character is deemed ",Object(c.b)("em",{parentName:"p"},"wasted")," because it doesn’t add a\nnew permutation to the string. It does however prepare the string for a\nsubsequent ‘3’ which adds the 213 permutation."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"The term ‘wasted’ is a bit harsh since the character is useful, it just doesn’t add a new permutation."),Object(c.b)("p",null,"Now that we understand wasted characters, subproblems are defined as:"),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"How many permutations can fit into a string that has W wasted characters?")),Object(c.b)("p",null,"The ",Object(c.b)("span",{ref:n=createRef()},"algorithm")," starts by solving the W=0 case\nby depth-first search. It enumerates all strings that do not waste any\ncharacters and counts how many permutations appear in them. The maximal count\nof permutations is the solution of the subproblem."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"For W=0, the solution is always equal to N since that’s the longest string before we hit a cycle: ‘12312’"),Object(c.b)("h3",null,"Climbing a ladder"),Object(c.b)("p",null,"The algorithm proceeds to solve the W=1 subproblem, using the solution of W=0 to\nspeed up the search. ",Object(c.b)("span",{ref:n=createRef()},"This")," works by pruning\nstrings that can’t possibly produce a maximal count of permutations because\nthey’ve already wasted too many characters."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"This is an example of ",Object(c.b)("a",s()({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Branch_and_bound"}),"branch and\nbound"),".")),Object(c.b)("p",null,"For ",Object(c.b)("span",{ref:n=createRef()},"example"),", when solving W=1, if we’ve seen\n‘12312132’ which contains five permutations, there’s no point expanding ‘1232’\nbecause we know from W=0 this string is doomed to failure. It can’t possible\nbeat the string with five permutations."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},"‘1232’ contains one permutation and wastes one character. In the best case, W=0 tells us we can add three permutations, totalling four."),Object(c.b)("p",null,"We then proceed to solve W=2, W=3 and so on. At each step we refer back to all\nprevious solutions to prune the search. The code looks something like this:"),Object(c.b)("span",{ref:n=createRef()}),Object(c.b)(d.a,{mdxType:"Figure"},Object(c.b)("pre",null,Object(c.b)("code",s()({parentName:"pre"},{className:"language-rust"}),"let surplus_waste = W - current_waste;\n\nlet max_perms = subproblem_solutions[surplus_waste];\nlet best_perms = current_perms + max_perms;\n\nif best_perms <= *best_seen_so_far {\n  return; // prune this string\n}\n")),Object(c.b)("p",null,"Pruning strings by using solutions to previous subproblems")),Object(c.b)(m.a,{target:n,moveDown:96,mdxType:"Aside"},Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"*best_seen_so_far")," points to a value shared across all branches of the\nsearch. If we ",Object(c.b)("a",s()({parentName:"p"},{href:"https://www.mathwarehouse.com/programming/passing-by-value-vs-by-reference-visual-explanation.php"}),"passed by\nvalue"),",\nneighbors wouldn’t see changes and we’d miss opportunities to prune.")),Object(c.b)("p",null,"A ",Object(c.b)("span",{ref:n=createRef()},"(contrived)")," analogy is to imagine\nclimbing a ladder. The search algorithm is working on one of the rungs and is\nsupported by preceding rungs to get its job done."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"contrived != helpful")),Object(c.b)("p",null,"The addition of Chaffin’s method has a dramatic impact on the effectiveness of\nthe ",Object(c.b)("span",{ref:n=createRef()},"search"),". For N=5, the search completes\nalmost instantly. Without this code, it grinds to a halt. It would likely take\na ",Object(c.b)("em",{parentName:"p"},"very")," long time to finish the search."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"I first read about Chaffin’s method in\n",Object(c.b)("a",s()({parentName:"p"},{href:"http://www.njohnston.ca/2014/08/all-minimal-superpermutations-on-five-symbols-have-been-found/"}),"this article")," by Nathaniel Johnston.")),Object(c.b)("h3",null,"Onwards"),Object(c.b)("p",null,"In part two I’ll walk through the code and go into much more detail about how\nthe algorithm ",Object(c.b)("em",{parentName:"p"},"actually")," works. I haven’t written part two yet so check back\nin a couple of weeks. I’ll also announce its publication\n",Object(c.b)("a",s()({parentName:"p"},{href:"https://twitter.com/chrispatuzzo"}),"on Twitter"),"."),Object(c.b)("p",null,"If you can’t wait, the ",Object(c.b)("span",{ref:n=createRef()},"latest")," iteration of\nmy (scrappy) code is ",Object(c.b)("a",s()({parentName:"p"},{href:"https://github.com/tuzz/chaffin-variation-rust-v2"}),"here"),"."),Object(c.b)(m.a,{target:n,mdxType:"Aside"},Object(c.b)("p",null,"There’s also\n",Object(c.b)("a",s()({parentName:"p"},{href:"https://github.com/tuzz/chaffin-variation"}),"this")," and\n",Object(c.b)("a",s()({parentName:"p"},{href:"https://github.com/tuzz/chaffin-variation-rust"}),"this"),".")),Object(c.b)(l.a,{previous:h.addingBashCompletion,next:h.reactCommentarySidebar,mdxType:"NavBar"}))}N.isMDXComponent=!0}}]);